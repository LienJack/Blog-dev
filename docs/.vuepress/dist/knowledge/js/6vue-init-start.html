<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 的初始化之开篇 | 个人主页</title>
    <meta name="description" content="lien的知识库">
    
    
    <link rel="preload" href="/Blog/assets/css/0.styles.a52f7505.css" as="style"><link rel="preload" href="/Blog/assets/js/app.cdba929c.js" as="script"><link rel="preload" href="/Blog/assets/js/12.c3f56d7b.js" as="script"><link rel="prefetch" href="/Blog/assets/js/10.ffaea7b6.js"><link rel="prefetch" href="/Blog/assets/js/11.68cb89c6.js"><link rel="prefetch" href="/Blog/assets/js/13.c9c51a46.js"><link rel="prefetch" href="/Blog/assets/js/14.e84b061f.js"><link rel="prefetch" href="/Blog/assets/js/15.3b4cc0f6.js"><link rel="prefetch" href="/Blog/assets/js/16.96c6021e.js"><link rel="prefetch" href="/Blog/assets/js/17.e2982de3.js"><link rel="prefetch" href="/Blog/assets/js/18.d9a15a58.js"><link rel="prefetch" href="/Blog/assets/js/19.d99e73c0.js"><link rel="prefetch" href="/Blog/assets/js/2.f408895a.js"><link rel="prefetch" href="/Blog/assets/js/20.c5f4581d.js"><link rel="prefetch" href="/Blog/assets/js/21.3438a0b8.js"><link rel="prefetch" href="/Blog/assets/js/22.015a194d.js"><link rel="prefetch" href="/Blog/assets/js/23.efaebbb4.js"><link rel="prefetch" href="/Blog/assets/js/24.585b0621.js"><link rel="prefetch" href="/Blog/assets/js/25.ce34ef53.js"><link rel="prefetch" href="/Blog/assets/js/26.3ba8840d.js"><link rel="prefetch" href="/Blog/assets/js/3.9a2081a3.js"><link rel="prefetch" href="/Blog/assets/js/4.96ff7512.js"><link rel="prefetch" href="/Blog/assets/js/5.0b98e5f3.js"><link rel="prefetch" href="/Blog/assets/js/6.a43352fb.js"><link rel="prefetch" href="/Blog/assets/js/7.d7e26d93.js"><link rel="prefetch" href="/Blog/assets/js/8.b6302fc1.js"><link rel="prefetch" href="/Blog/assets/js/9.39a6e0ed.js">
    <link rel="stylesheet" href="/Blog/assets/css/0.styles.a52f7505.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Blog/" class="home-link router-link-active"><!----> <span class="site-name">个人主页</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Blog/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">知识</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Blog/knowledge/js/" class="nav-link router-link-active">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/Blog/lien-ui/" class="nav-link">UI框架</a></li><li class="dropdown-item"><!----> <a href="/Blog/about/" class="nav-link">关于</a></li></ul></div></div><div class="nav-item"><a href="/Blog/work/" class="nav-link">工程</a></div><div class="nav-item"><a href="/Blog/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="https://github.com/LienJack/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Blog/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">知识</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Blog/knowledge/js/" class="nav-link router-link-active">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/Blog/lien-ui/" class="nav-link">UI框架</a></li><li class="dropdown-item"><!----> <a href="/Blog/about/" class="nav-link">关于</a></li></ul></div></div><div class="nav-item"><a href="/Blog/work/" class="nav-link">工程</a></div><div class="nav-item"><a href="/Blog/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="https://github.com/LienJack/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>javascript</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/Blog/knowledge/js/" class="sidebar-link">了解js</a></li><li><a href="/Blog/knowledge/js/1start-learn.html" class="sidebar-link">了解 Vue 这个项目</a></li><li><a href="/Blog/knowledge/js/2vue-constructor.html" class="sidebar-link">Vue 构造函数</a></li><li><a href="/Blog/knowledge/js/3vue-example.html" class="sidebar-link">以一个例子为线索</a></li><li><a href="/Blog/knowledge/js/4vue-normalize.html" class="sidebar-link">Vue 选项的规范化</a></li><li><a href="/Blog/knowledge/js/5vue-merge.html" class="sidebar-link">Vue 选项的合并</a></li><li><a href="/Blog/knowledge/js/6vue-init-start.html" class="active sidebar-link">Vue 的初始化之开篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Blog/knowledge/js/6vue-init-start.html#用于初始化的最终选项-options" class="sidebar-link">用于初始化的最终选项 $options</a></li><li class="sidebar-sub-header"><a href="/Blog/knowledge/js/6vue-init-start.html#渲染函数的作用域代理" class="sidebar-link">渲染函数的作用域代理</a></li><li class="sidebar-sub-header"><a href="/Blog/knowledge/js/6vue-init-start.html#初始化之-initlifecycle" class="sidebar-link">初始化之 initLifecycle</a></li><li class="sidebar-sub-header"><a href="/Blog/knowledge/js/6vue-init-start.html#初始化之-initevents" class="sidebar-link">初始化之 initEvents</a></li><li class="sidebar-sub-header"><a href="/Blog/knowledge/js/6vue-init-start.html#初始化之-initrender" class="sidebar-link">初始化之 initRender</a></li><li class="sidebar-sub-header"><a href="/Blog/knowledge/js/6vue-init-start.html#生命周期钩子的实现方式" class="sidebar-link">生命周期钩子的实现方式</a></li><li class="sidebar-sub-header"><a href="/Blog/knowledge/js/6vue-init-start.html#vue-的初始化之-initstate" class="sidebar-link">Vue 的初始化之 initState</a></li></ul></li><li><a href="/Blog/knowledge/js/7vue-reactive.html" class="sidebar-link">揭开数据响应系统的面纱</a></li><li><a href="/Blog/knowledge/js/8vue-reactive-dep-watch.html" class="sidebar-link">渲染函数的观察者与进阶的数据响应系统</a></li><li><a href="/Blog/knowledge/js/9vue-state-init.html" class="sidebar-link">其他重要选项的初始化及实现</a></li><li><a href="/Blog/knowledge/js/80vue-compiler-start.html" class="sidebar-link">Vue 的编译器初探</a></li><li><a href="/Blog/knowledge/js/81vue-lexical-analysis.html" class="sidebar-link">词法分析 - 为生成AST做准备</a></li><li><a href="/Blog/knowledge/js/82vue-parsing.html" class="sidebar-link">句法分析 - 生成真正的AST(一)</a></li><li><a href="/Blog/knowledge/js/83vue-parsing-2.html" class="sidebar-link">句法分析 - 生成真正的AST(二)</a></li><li><a href="/Blog/knowledge/js/84vue-codegen.html" class="sidebar-link">编译器之代码的生成</a></li><li><a href="/Blog/knowledge/js/85vue-vdom.html" class="sidebar-link">虚拟DOM解析</a></li><li><a href="/Blog/knowledge/js/86vue-vdom-patch.html" class="sidebar-link">虚拟DOM补丁算法详解</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="vue-的初始化之开篇"><a href="#vue-的初始化之开篇" aria-hidden="true" class="header-anchor">#</a> Vue 的初始化之开篇</h1> <h2 id="用于初始化的最终选项-options"><a href="#用于初始化的最终选项-options" aria-hidden="true" class="header-anchor">#</a> 用于初始化的最终选项 $options</h2> <p>在 <a href="/Blog/knowledge/js/3vue-example.html">以一个例子为线索</a> 一节中，我们写了一个很简单的例子，这个例子如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        test<span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>我们以这个例子为线索开始了对 <code>Vue</code> 代码的讲解，我们知道了在实例化 <code>Vue</code> 实例的时候，<code>Vue.prototype._init</code> 方法被第一个执行，这个方法定义在 <code>src/core/instance/init.js</code> 文件中，在分析 <code>_init</code> 方法的时候我们遇到了下面的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code>vm<span class="token punctuation">.</span>$options <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>
    <span class="token function">resolveConstructorOptions</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">,</span>
    options <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    vm
<span class="token punctuation">)</span>
</code></pre></div><p>正是因为上面的代码，使得我们花了大篇章来讲解其内部实现和运作，也就是 <a href="/Blog/knowledge/js/vue-normalize.html">Vue选项的规范化</a> 和 <a href="/Blog/knowledge/js/vue-normalize.html">Vue选项的合并</a> 这两节所介绍的内容。现在我们已经知道了 <code>mergeOptions</code> 函数是如何对父子选项进行合并处理的，也知道了它的作用。</p> <p>我们打开 <code>core/util/options.js</code> 文件，找到 <code>mergeOptions</code> 函数，看其最后一句代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">return</span> options
</code></pre></div><p>这说明 <code>mergeOptions</code> 函数最终将合并处理后的选项返回，并以该返回值作为 <code>vm.$options</code> 的值。<code>vm.$options</code> 在 <code>Vue</code> 的官方文档中是可以找到的，它作为实例属性暴露给开发者，那么现在你应该知道 <code>vm.$options</code> 到底是什么了。并且看文档的时候你应该更能够理解其作用，比如官方文档是这样介绍 <code>$options</code> 实例属性的：</p> <blockquote><p>用于当前 <code>Vue</code> 实例的初始化选项。需要在选项中包含自定义属性时会有用处</p></blockquote> <p>并且给了一个例子，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  customOption<span class="token punctuation">:</span> <span class="token string">'foo'</span><span class="token punctuation">,</span>
  created<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$options<span class="token punctuation">.</span>customOption<span class="token punctuation">)</span> <span class="token comment">// =&gt; 'foo'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>上面的例子中，在创建 <code>Vue</code> 实例的时候传递了一个自定义选项：<code>customOption</code>，在之后的代码中我们可以通过 <code>this.$options.customOption</code> 进行访问。那原理其实就是使用 <code>mergeOptions</code> 函数对自定义选项进行合并处理，由于没有指定 <code>customOption</code> 选项的合并策略，所以将会使用默认的策略函数 <code>defaultStrat</code>。最终效果就是你初始化的值是什么，得到的就是什么。</p> <p>另外，<code>Vue</code> 也提供了 <code>Vue.config.optionMergeStrategies</code> 全局配置，大家也可以在官方文档中找到，我们知道这个对象其实就是选项合并中的策略对象，所以我们可以通过他指定某一个选项的合并策略，常用于指定自定义选项的合并策略，比如我们给 <code>customOption</code> 选项指定一个合并策略，只需要在 <code>Vue.config.optionMergeStrategies</code> 上添加与选项同名的策略函数即可：</p> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>optionMergeStrategies<span class="token punctuation">.</span><span class="token function-variable function">customOption</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>parentVal<span class="token punctuation">,</span> childVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> parentVal <span class="token operator">?</span> <span class="token punctuation">(</span>parentVal <span class="token operator">+</span> childVal<span class="token punctuation">)</span> <span class="token punctuation">:</span> childVal
<span class="token punctuation">}</span>
</code></pre></div><p>如上代码中，我们添加了自定义选项 <code>customOption</code> 的合并策略，其策略为：如果没有 <code>parentVal</code> 则直接返回 <code>childVal</code>，否则返回两者的和。</p> <p>所以如下代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 创建子类</span>
<span class="token keyword">const</span> Sub <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    customOption<span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 以子类创建实例</span>
<span class="token keyword">const</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    customOption<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    <span class="token function">created</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$options<span class="token punctuation">.</span>customOption<span class="token punctuation">)</span> <span class="token comment">// 3</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>最终，在实例的 <code>created</code> 方法中将打印数字 <code>3</code>。上面的例子很简单，没有什么实际作用，但这为我们提供了自定义选项的机会，这其实是非常有用的。</p> <p>现在我们需要回到正题上了，还是拿我们的例子，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        test<span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>这个时候 <code>mergeOptions</code> 函数将会把 <code>Vue.options</code> 作为 父选项，把我们传递的实例选项作为子选项进行合并，合并的结果我们可以通过打印 <code>$options</code> 属性得知。其实我们前面已经分析过了，<code>el</code> 选项将使用默认合并策略合并，最终的值就是字符串 <code>'#app'</code>，而 <code>data</code> 选项将变成一个函数，且这个函数的执行结果就是合并后的数据，即： <code>{test: 1}</code>。</p> <p>下面是 <code>vm.$options</code> 的截图：</p> <p><img src="http://ovjvjtt4l.bkt.clouddn.com/2017-11-02-083231.jpg" alt></p> <p>我们发现 <code>el</code> 确实还是原来的值，而 <code>data</code> 也确实变成了一个函数，并且这个函数就是我们之前遇到过的 <code>mergedInstanceDataFn</code>，除此之外我们还能看到其他合并后的选项，其中 <code>components</code>、<code>directives</code>、<code>filters</code> 以及 <code>_base</code> 是存在于 <code>Vue.options</code> 中的，这些是我们所知道的，至于 <code>render</code> 和 <code>staticRenderFns</code> 这两个选项是在将模板编译成渲染函数时添加上去的，我们后面会遇到。另外 <code>_parentElm</code> 和 <code>_refElm</code> 这两个选项是在为虚拟DOM创建组件实例时添加的，我们后面也会讲到，这里大家不需要关心，免得失去重点。</p> <h2 id="渲染函数的作用域代理"><a href="#渲染函数的作用域代理" aria-hidden="true" class="header-anchor">#</a> 渲染函数的作用域代理</h2> <p>ok，现在我们已经足够了解 <code>vm.$options</code> 这个属性了，它才是用来做一系列初始化工作的最终选项，那么接下来我们就继续看 <code>_init</code> 方法中的代码，继续了解 <code>Vue</code> 的初始化工作。</p> <p><code>_init</code> 方法中，在经过 <code>mergeOptions</code> 合并处理选项之后，要执行的是下面这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/* istanbul ignore else */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">initProxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    vm<span class="token punctuation">.</span>_renderProxy <span class="token operator">=</span> vm
<span class="token punctuation">}</span>
</code></pre></div><p>这段代码是一个判断分支，如果是非生产环境的话则执行 <code>initProxy(vm)</code> 函数，如果在生产环境则直接在实例上添加 <code>_renderProxy</code> 实例属性，该属性的值就是当前实例。</p> <p>现在有一个问题需要大家思考一下，目前我们还没有看 <code>initProxy</code> 函数的具体内容，那么你能猜到 <code>initProxy</code> 函数的主要作用是什么吗？我可以直接告诉大家，这个函数的主要作用其实就是在实例对象 <code>vm</code> 上添加 <code>_renderProxy</code> 属性。为什么呢？因为生产环境和非生产环境下要保持功能一致。在上面的代码中生产环境下直接执行这句：</p> <div class="language-js extra-class"><pre class="language-js"><code>vm<span class="token punctuation">.</span>_renderProxy <span class="token operator">=</span> vm
</code></pre></div><p>那么可想而知，在非生产环境下也应该执行这句代码，但实际上却调用了 <code>initProxy</code> 函数，所以 <code>initProxy</code> 函数的作用之一必然也是在实例对象 <code>vm</code> 上添加 <code>_renderProxy</code> 属性，那么接下来我们就看看 <code>initProxy</code> 的内容，验证一下我们的判断，打开 <code>core/instance/proxy.js</code> 文件：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/* not type checking this file because flow doesn't play well with Proxy */</span>

<span class="token keyword">import</span> config <span class="token keyword">from</span> <span class="token string">'core/config'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> warn<span class="token punctuation">,</span> makeMap <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'../util/index'</span>

<span class="token comment">// 声明 initProxy 变量</span>
<span class="token keyword">let</span> initProxy

<span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... 其他代码</span>
  
  <span class="token comment">// 在这里初始化 initProxy</span>
  <span class="token function-variable function">initProxy</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">initProxy</span> <span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hasProxy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// determine which proxy handler to use</span>
      <span class="token keyword">const</span> options <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options
      <span class="token keyword">const</span> handlers <span class="token operator">=</span> options<span class="token punctuation">.</span>render <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>render<span class="token punctuation">.</span>_withStripped
        <span class="token operator">?</span> getHandler
        <span class="token punctuation">:</span> hasHandler
      vm<span class="token punctuation">.</span>_renderProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> handlers<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span>_renderProxy <span class="token operator">=</span> vm
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 导出</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> initProxy <span class="token punctuation">}</span>
</code></pre></div><p>上面的代码是简化后的，可以发现在文件的开头声明了 <code>initProxy</code> 变量，但并未初始化，所以目前 <code>initProxy</code> 还是 <code>undefined</code>，随后，在文件的结尾将 <code>initProxy</code> 导出，那么 <code>initProxy</code> 到底是什么呢？实际上变量 <code>initProxy</code> 的赋值是在 <code>if</code> 语句块内进行的，这个 <code>if</code> 语句块进行环境判断，如果是非生产环境的话，那么才会对 <code>initProxy</code> 变量赋值，也就是说在生产环境下我们导出的 <code>initProxy</code> 实际上就是 <code>undefined</code>。只有在非生产环境下导出的 <code>initProxy</code> 才会有值，其值就是这个函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">initProxy</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">initProxy</span> <span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hasProxy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// determine which proxy handler to use</span>
        <span class="token keyword">const</span> options <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options
        <span class="token keyword">const</span> handlers <span class="token operator">=</span> options<span class="token punctuation">.</span>render <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>render<span class="token punctuation">.</span>_withStripped
        <span class="token operator">?</span> getHandler
        <span class="token punctuation">:</span> hasHandler
        vm<span class="token punctuation">.</span>_renderProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> handlers<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        vm<span class="token punctuation">.</span>_renderProxy <span class="token operator">=</span> vm
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个函数接收一个参数，实际就是 <code>Vue</code> 实例对象，我们先从宏观角度来看一下这个函数的作用是什么，可以发现，这个函数由 <code>if...else</code> 语句块组成，但无论走 <code>if</code> 还是 <code>else</code>，其最终的效果都是在 <code>vm</code> 对象上添加了 <code>_renderProxy</code> 属性，这就验证了我们之前的猜想。如果 <code>hasProxy</code> 为真则走 <code>if</code> 分支，对于 <code>hasProxy</code> 顾名思义，这是用来判断宿主环境是否支持 <code>js</code> 原生的 <code>Proxy</code> 特性的，如果发现 <code>Proxy</code> 存在，则执行：</p> <div class="language-js extra-class"><pre class="language-js"><code>vm<span class="token punctuation">.</span>_renderProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> handlers<span class="token punctuation">)</span>
</code></pre></div><p>如果不存在，那么和生产环境一样，直接赋值就可以了：</p> <div class="language-js extra-class"><pre class="language-js"><code>vm<span class="token punctuation">.</span>_renderProxy <span class="token operator">=</span> vm
</code></pre></div><p>所以我们发现 <code>initProxy</code> 的作用实际上就是对实例对象 <code>vm</code> 的代理，通过原生的 <code>Proxy</code> 实现。</p> <p>另外 <code>hasProxy</code> 变量的定义也在当前文件中，代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> hasProxy <span class="token operator">=</span>
    <span class="token keyword">typeof</span> Proxy <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span>
    Proxy<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/native code/</span><span class="token punctuation">)</span>
</code></pre></div><p>上面代码的作用是判断当前宿主环境是否支持原生 <code>Proxy</code>，相信大家都能看得懂，所以就不做过多解释，接下来我们就看看它是如何做代理的，并且有什么作用。</p> <p>查看 <code>initProxy</code> 函数的 <code>if</code> 语句块，内容如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">initProxy</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">initProxy</span> <span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hasProxy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// determine which proxy handler to use</span>
        <span class="token comment">// options 就是 vm.$options 的引用</span>
        <span class="token keyword">const</span> options <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options
        <span class="token comment">// handlers 可能是 getHandler 也可能是 hasHandler</span>
        <span class="token keyword">const</span> handlers <span class="token operator">=</span> options<span class="token punctuation">.</span>render <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>render<span class="token punctuation">.</span>_withStripped
            <span class="token operator">?</span> getHandler
            <span class="token punctuation">:</span> hasHandler
        <span class="token comment">// 代理 vm 对象</span>
        vm<span class="token punctuation">.</span>_renderProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> handlers<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以发现，如果 <code>Proxy</code> 存在，那么将会使用 <code>Proxy</code> 对 <code>vm</code> 做一层代理，代理对象赋值给 <code>vm._renderProxy</code>，所以今后对 <code>vm._renderProxy</code> 的访问，如果有代理那么就会被拦截。代理对象配置参数是 <code>handlers</code>，可以发现 <code>handlers</code> 既可能是 <code>getHandler</code> 又可能是 <code>hasHandler</code>，至于到底使用哪个，是由判断条件决定的：</p> <div class="language-js extra-class"><pre class="language-js"><code>options<span class="token punctuation">.</span>render <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>render<span class="token punctuation">.</span>_withStripped
</code></pre></div><p>如果上面的条件为真，则使用 <code>getHandler</code>，否则使用 <code>hasHandler</code>，判断条件要求 <code>options.render</code> 和 <code>options.render._withStripped</code> 必须都为真才行，我现在明确告诉大家 <code>options.render._withStripped</code> 这个属性只在测试代码中出现过，所以一般情况下这个条件都会为假，也就是使用 <code>hasHandler</code> 作为代理配置。</p> <p><code>hasHandler</code> 常量就定义在当前文件，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> hasHandler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">has</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// has 常量是真实经过 in 运算符得来的结果</span>
        <span class="token keyword">const</span> has <span class="token operator">=</span> key <span class="token keyword">in</span> target
        <span class="token comment">// 如果 key 在 allowedGlobals 之内，或者 key 是以下划线 _ 开头的字符串，则为真</span>
        <span class="token keyword">const</span> isAllowed <span class="token operator">=</span> <span class="token function">allowedGlobals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> key <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'_'</span><span class="token punctuation">)</span>
        <span class="token comment">// 如果 has 和 isAllowed 都为假，使用 warnNonPresent 函数打印错误</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>has <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">warnNonPresent</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> has <span class="token operator">||</span> <span class="token operator">!</span>isAllowed
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里我假设大家都对 <code>Proxy</code> 的使用已经没有任何问题了，我们知道 <code>has</code> 可以拦截以下操作：</p> <ul><li>属性查询: foo in proxy</li> <li>继承属性查询: foo in Object.create(proxy)</li> <li>with 检查: with(proxy) { (foo); }</li> <li>Reflect.has()</li></ul> <p>其中关键点就在 <code>has</code> 可以拦截 <code>with</code> 语句块里对变量的访问，后面我们会讲到。</p> <p><code>has</code> 函数内出现了两个函数，分别是 <code>allowedGlobals</code> 以及 <code>warnNonPresent</code>，这两个函数也是定义在当前文件中，首先我们看一下 <code>allowedGlobals</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> allowedGlobals <span class="token operator">=</span> <span class="token function">makeMap</span><span class="token punctuation">(</span>
    <span class="token string">'Infinity,undefined,NaN,isFinite,isNaN,'</span> <span class="token operator">+</span>
    <span class="token string">'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,'</span> <span class="token operator">+</span>
    <span class="token string">'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,'</span> <span class="token operator">+</span>
    <span class="token string">'require'</span> <span class="token comment">// for Webpack/Browserify</span>
<span class="token punctuation">)</span>
</code></pre></div><p>可以看到 <code>allowedGlobals</code> 实际上是通过 <code>makeMap</code> 生成的函数，所以 <code>allowedGlobals</code> 函数的作用是判断给定的 <code>key</code> 是否出现在上面字符串中定义的关键字中的。这些关键字都是在 <code>js</code> 中可以全局访问的。</p> <p><code>warnNonPresent</code> 函数如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">warnNonPresent</span> <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">warn</span><span class="token punctuation">(</span>
        <span class="token template-string"><span class="token string">`Property or method &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; is not defined on the instance but `</span></span> <span class="token operator">+</span>
        <span class="token string">'referenced during render. Make sure that this property is reactive, '</span> <span class="token operator">+</span>
        <span class="token string">'either in the data option, or for class-based components, by '</span> <span class="token operator">+</span>
        <span class="token string">'initializing the property. '</span> <span class="token operator">+</span>
        <span class="token string">'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.'</span><span class="token punctuation">,</span>
        target
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个函数就是通过 <code>warn</code> 打印一段警告信息，警告信息提示你“在渲染的时候引用了 <code>key</code>，但是在实例对象上并没有定义 <code>key</code> 这个属性或方法”。其实我们很容易就可以看到这个信息，比如下面的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    template<span class="token punctuation">:</span> <span class="token string">'&lt;div&gt;{{a}}&lt;/div&gt;'</span><span class="token punctuation">,</span>
    data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        test<span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>大家注意，在模板中我们使用 <code>a</code>，但是在 <code>data</code> 属性中并没有定义这个属性，这个时候我们就能够得到以上报错信息：</p> <p><img src="http://ovjvjtt4l.bkt.clouddn.com/2017-11-03-073757.jpg" alt></p> <p>大家可能比较疑惑的是为什么会这样，其实我们后面讲到渲染函数的时候你自然就知道了，不过现在大家可以先看一下，打开 <code>core/instance/render.js</code> 文件，找到 <code>Vue.prototype._render</code> 方法，里面有这样的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code>vnode <span class="token operator">=</span> render<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_renderProxy<span class="token punctuation">,</span> vm<span class="token punctuation">.</span>$createElement<span class="token punctuation">)</span>
</code></pre></div><p>可以发现，调用 <code>render</code> 函数的时候，使用 <code>call</code> 方法指定了函数的执行环境为 <code>vm._renderProxy</code>，渲染函数长成什么样呢？还是以上面的例子为例，我们可以通过打印 <code>vm.$options.render</code> 查看，所以它长成这样：</p> <div class="language-js extra-class"><pre class="language-js"><code>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span><span class="token function-variable function">render</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// render 函数的 this 指向实例的 _renderProxy</span>
    <span class="token keyword">with</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token function">_v</span><span class="token punctuation">(</span><span class="token function">_s</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment">// 在这里访问 a，相当于访问 vm._renderProxy.a</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从上面的代码可以发现，显然函数使用 <code>with</code> 语句块指定了内部代码的执行环境为 <code>this</code>，由于 <code>render</code> 函数调用的时候使用 <code>call</code> 指定了其 <code>this</code> 指向为 <code>vm._renderProxy</code>，所以 <code>with</code> 语句块内代码的执行环境就是 <code>vm._renderProxy</code>，所以在 <code>with</code> 语句块内访问 <code>a</code> 就相当于访问 <code>vm._renderProxy</code> 的 <code>a</code> 属性，前面我们提到过 <code>with</code> 语句块内访问变量将会被 <code>Proxy</code> 的 <code>has</code> 代理所拦截，所以自然就执行了 <code>has</code> 函数内的代码。最终通过 <code>warnNonPresent</code> 打印警告信息给我们，所以这个代理的作用就是为了在开发阶段给我们一个友好而准确的提示。</p> <p>我们理解了 <code>hasHandler</code>，但是还有一个 <code>getHandler</code>，这个代理将会在判断条件：</p> <div class="language-js extra-class"><pre class="language-js"><code>options<span class="token punctuation">.</span>render <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>render<span class="token punctuation">.</span>_withStripped
</code></pre></div><p>为真的情况下被使用，那这个条件什么时候成立呢？其实 <code>_withStripped</code> 只在 <code>test/unit/features/instance/render-proxy.spec.js</code> 文件中出现过，该文件有这样一段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">it</span><span class="token punctuation">(</span><span class="token string">'should warn missing property in render fns without `with`'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token function-variable function">render</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里访问了 a</span>
        <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 在这里将 render._withStripped 设置为 true</span>
    render<span class="token punctuation">.</span>_withStripped <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        render
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 应该得到警告</span>
    <span class="token function">expect</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Property or method &quot;a&quot; is not defined`</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toHaveBeenWarned</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>这个时候就会触发 <code>getHandler</code> 设置的 <code>get</code> 拦截，<code>getHandler</code> 代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> getHandler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token keyword">get</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> key <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">warnNonPresent</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其最终实现的效果无非就是检测到访问的属性不存在就给你一个警告。但我们也提到了，只有当 <code>render</code> 函数的 <code>_withStripped</code> 为真的时候，才会给出警告，但是 <code>render._withStripped</code> 又只有写测试的时候出现过，也就是说需要我们手动设置其为 <code>true</code> 才会得到提示，否则是得不到的，比如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">render</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    render<span class="token punctuation">,</span>
    data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        test<span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>上面的代码由于 <code>render</code> 函数是我们手动书写的，所以 <code>render</code> 函数并不会被包裹在 <code>with</code> 语句块内，当然也就触发不了 <code>has</code> 拦截，但是由于 <code>render._withStripped</code> 也未定义，所以也不会被 <code>get</code> 拦截，那这个时候我们虽然访问了不存在的 <code>this.a</code>，但是却得不到警告，想要得到警告我们需要手动设置 <code>render._withStripped</code> 为 <code>true</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">render</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
render<span class="token punctuation">.</span>_withStripped <span class="token operator">=</span> <span class="token boolean">true</span>

<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    render<span class="token punctuation">,</span>
    data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        test<span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>为什么会这么设计呢？因为在使用 <code>webpack</code> 配合 <code>vue-loader</code> 的环境中， <code>vue-loader</code> 会借助 <a href="https://github.com/vuejs/component-compiler-utils" target="_blank" rel="noopener noreferrer"><code>vuejs@component-compiler-utils</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 将 <code>template</code> 编译为不使用 <code>with</code> 语句包裹的遵循严格模式的 JavaScript，并为编译后的 <code>render</code> 方法设置 <code>render._withStripped = true</code>。在不使用 <code>with</code> 语句的 <code>render</code> 方法中，模板内的变量都是通过属性访问操作 <code>vm['a']</code> 或 <code>vm.a</code> 的形式访问的，从前文中我们了解到 <code>Proxy</code> 的 <code>has</code> 无法拦截属性访问操作，所以这里需要使用 <code>Proxy</code> 中可以拦截到属性访问的 <code>get</code>，同时也省去了 <code>has</code> 中的全局变量检查(全局变量的访问不会被 <code>get</code> 拦截)。</p> <p>现在，我们基本知道了 <code>initProxy</code> 的目的，就是设置渲染函数的作用域代理，其目的是为我们提供更好的提示信息。但是我们忽略了一些细节没有讲清楚，回到下面这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// has 变量是真实经过 in 运算符得来的结果</span>
<span class="token keyword">const</span> has <span class="token operator">=</span> key <span class="token keyword">in</span> target
<span class="token comment">// 如果 key 在 allowedGlobals 之内，或者 key 是以下划线 _ 开头的字符串，则为真</span>
<span class="token keyword">const</span> isAllowed <span class="token operator">=</span> <span class="token function">allowedGlobals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> key <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'_'</span><span class="token punctuation">)</span>
<span class="token comment">// 如果 has 和 isAllowed 都为假，使用 warnNonPresent 函数打印错误</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>has <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">warnNonPresent</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面这段代码中的 <code>if</code> 语句的判断条件是 <code>(!has &amp;&amp; !isAllowed)</code>，其中 <code>!has</code> 我们可以理解为<strong>你访问了一个没有定义在实例对象上(或原型链上)的属性</strong>，所以这个时候提示错误信息是合理，但是即便 <code>!has</code> 成立也不一定要提示错误信息，因为必须要满足 <code>!isAllowed</code>，也就是说当你访问了一个<strong>虽然不在实例对象上(或原型链上)的属性，但如果你访问的是全局对象</strong>那么也是被允许的。这样我们就可以在模板中使用全局对象了，如：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  {{Number(b) + 2}}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>其中 <code>Number</code> 为全局对象，如果去掉 <code>!isAllowed</code> 这个判断条件，那么上面模板的写法将会得到警告信息。除了允许使用全局对象之外，还允许以 <code>_</code> 开头的属性，这么做是由于渲染函数中会包含很多以 <code>_</code> 开头的内部方法，如之前我们查看渲染函数时遇到的 <code>_c</code>、<code>_v</code> 等等。</p> <p>最后对于 <code>proxy.js</code> 文件内的代码，还有一段是我们没有讲过的，就是下面这段：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>hasProxy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// isBuiltInModifier 函数用来检测是否是内置的修饰符</span>
    <span class="token keyword">const</span> isBuiltInModifier <span class="token operator">=</span> <span class="token function">makeMap</span><span class="token punctuation">(</span><span class="token string">'stop,prevent,self,ctrl,shift,alt,meta,exact'</span><span class="token punctuation">)</span>
    <span class="token comment">// 为 config.keyCodes 设置 set 代理，防止内置修饰符被覆盖</span>
    config<span class="token punctuation">.</span>keyCodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>keyCodes<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token keyword">set</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isBuiltInModifier</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Avoid overwriting built-in modifier in config.keyCodes: .</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
                <span class="token keyword">return</span> <span class="token boolean">true</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面的代码首先检测宿主环境是否支持 <code>Proxy</code>，如果支持的话才会执行里面的代码，内部的代码首先使用 <code>makeMap</code> 函数生成一个 <code>isBuiltInModifier</code> 函数，该函数用来检测给定的值是否是内置的事件修饰符，我们知道在 <code>Vue</code> 中我们可以使用事件修饰符很方便地做一些工作，比如阻止默认事件等。</p> <p>然后为 <code>config.keyCodes</code> 设置了 <code>set</code> 代理，其目的是防止开发者在自定义键位别名的时候，覆盖了内置的修饰符，比如：</p> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>keyCodes<span class="token punctuation">.</span>shift <span class="token operator">=</span> <span class="token number">16</span>
</code></pre></div><p>由于 <code>shift</code> 是内置的修饰符，所以上面这句代码将会得到警告。</p> <h2 id="初始化之-initlifecycle"><a href="#初始化之-initlifecycle" aria-hidden="true" class="header-anchor">#</a> 初始化之 initLifecycle</h2> <p><code>_init</code> 函数在执行完 <code>initProxy</code> 之后，执行的就是 <code>initLifecycle</code> 函数：</p> <div class="language-js extra-class"><pre class="language-js"><code>vm<span class="token punctuation">.</span>_self <span class="token operator">=</span> vm
<span class="token function">initLifecycle</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
</code></pre></div><p>在 <code>initLifecycle</code> 函数执行之前，执行了 <code>vm._self = vm</code> 语句，这句话在 <code>Vue</code> 实例对象 <code>vm</code> 上添加了 <code>_self</code> 属性，指向真实的实例本身。注意 <code>vm._self</code> 和 <code>vm._renderProxy</code> 不同，首先在用途上来说寓意是不同的，另外 <code>vm._renderProxy</code> 有可能是一个代理对象，即 <code>Proxy</code> 实例。</p> <p>接下来执行的才是 <code>initLifecycle</code> 函数，同时将当前 <code>Vue</code> 实例 <code>vm</code> 作为参数传递。打开 <code>core/instance/lifecycle.js</code> 文件找到 <code>initLifecycle</code> 函数，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">initLifecycle</span> <span class="token punctuation">(</span>vm<span class="token punctuation">:</span> Component<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义 options，它是 vm.$options 的引用，后面的代码使用的都是 options 常量</span>
  <span class="token keyword">const</span> options <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options

  <span class="token comment">// locate first non-abstract parent</span>
  <span class="token keyword">let</span> parent <span class="token operator">=</span> options<span class="token punctuation">.</span>parent
  <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>options<span class="token punctuation">.</span>abstract<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>abstract <span class="token operator">&amp;&amp;</span> parent<span class="token punctuation">.</span>$parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parent <span class="token operator">=</span> parent<span class="token punctuation">.</span>$parent
    <span class="token punctuation">}</span>
    parent<span class="token punctuation">.</span>$children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  vm<span class="token punctuation">.</span>$parent <span class="token operator">=</span> parent
  vm<span class="token punctuation">.</span>$root <span class="token operator">=</span> parent <span class="token operator">?</span> parent<span class="token punctuation">.</span>$root <span class="token punctuation">:</span> vm

  vm<span class="token punctuation">.</span>$children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  vm<span class="token punctuation">.</span>$refs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  vm<span class="token punctuation">.</span>_watcher <span class="token operator">=</span> <span class="token keyword">null</span>
  vm<span class="token punctuation">.</span>_inactive <span class="token operator">=</span> <span class="token keyword">null</span>
  vm<span class="token punctuation">.</span>_directInactive <span class="token operator">=</span> <span class="token boolean">false</span>
  vm<span class="token punctuation">.</span>_isMounted <span class="token operator">=</span> <span class="token boolean">false</span>
  vm<span class="token punctuation">.</span>_isDestroyed <span class="token operator">=</span> <span class="token boolean">false</span>
  vm<span class="token punctuation">.</span>_isBeingDestroyed <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面代码是 <code>initLifecycle</code> 函数的全部内容，首先定义 <code>options</code> 常量，它是 <code>vm.$options</code> 的引用。接着将执行下面这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// locate first non-abstract parent (查找第一个非抽象的父组件)</span>
<span class="token comment">// 定义 parent，它引用当前实例的父实例</span>
<span class="token keyword">let</span> parent <span class="token operator">=</span> options<span class="token punctuation">.</span>parent
<span class="token comment">// 如果当前实例有父组件，且当前实例不是抽象的</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>options<span class="token punctuation">.</span>abstract<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 使用 while 循环查找第一个非抽象的父组件</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>abstract <span class="token operator">&amp;&amp;</span> parent<span class="token punctuation">.</span>$parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    parent <span class="token operator">=</span> parent<span class="token punctuation">.</span>$parent
  <span class="token punctuation">}</span>
  <span class="token comment">// 经过上面的 while 循环后，parent 应该是一个非抽象的组件，将它作为当前实例的父级，所以将当前实例 vm 添加到父级的 $children 属性里</span>
  parent<span class="token punctuation">.</span>$children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 设置当前实例的 $parent 属性，指向父级</span>
vm<span class="token punctuation">.</span>$parent <span class="token operator">=</span> parent
<span class="token comment">// 设置 $root 属性，有父级就是用父级的 $root，否则 $root 指向自身</span>
vm<span class="token punctuation">.</span>$root <span class="token operator">=</span> parent <span class="token operator">?</span> parent<span class="token punctuation">.</span>$root <span class="token punctuation">:</span> vm
</code></pre></div><p>上面代码的作用可以用一句话总结：<em>“将当前实例添加到父实例的 <code>$children</code> 属性里，并设置当前实例的 <code>$parent</code> 指向父实例”</em>。那么要实现这个目标首先要寻找到父级才行，那么父级的来源是哪里呢？就是这句话：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 定义 parent，它引用当前实例的父组件</span>
<span class="token keyword">let</span> parent <span class="token operator">=</span> options<span class="token punctuation">.</span>parent
</code></pre></div><p>通过读取 <code>options.parent</code> 获取父实例，但是问题来了，我们知道 <code>options</code> 是 <code>vm.$options</code> 的引用，所以这里的 <code>options.parent</code> 相当于 <code>vm.$options.parent</code>，那么 <code>vm.$options.parent</code> 从哪里来？比如下面的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 子组件本身并没有指定 parent 选项</span>
<span class="token keyword">var</span> ChildComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">created</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 但是在子组件中访问父实例，能够找到正确的父实例引用</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$options<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    components<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// 注册组件</span>
      ChildComponent
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        test<span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>我们知道 <code>Vue</code> 给我们提供了 <code>parent</code> 选项，使得我们可以手动指定一个组件的父实例，但在上面的例子中，我们并没有手动指定 <code>parent</code> 选项，但是子组件依然能够正确地找到它的父实例，这说明 <code>Vue</code> 在寻找父实例的时候是自动检测的。那它是怎么做的呢？目前不准备给大家介绍，因为时机还不够成熟，现在讲大家很容易懵，不过可以给大家看一段代码，打开 <code>core/vdom/create-component.js</code> 文件，里面有一个函数叫做 <code>createComponentInstanceForVnode</code>，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createComponentInstanceForVnode</span> <span class="token punctuation">(</span>
  vnode<span class="token punctuation">:</span> any<span class="token punctuation">,</span> <span class="token comment">// we know it's MountedComponentVNode but flow doesn't</span>
  parent<span class="token punctuation">:</span> any<span class="token punctuation">,</span> <span class="token comment">// activeInstance in lifecycle state</span>
  parentElm<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token operator">?</span>Node<span class="token punctuation">,</span>
  refElm<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token operator">?</span>Node
<span class="token punctuation">)</span><span class="token punctuation">:</span> Component <span class="token punctuation">{</span>
  <span class="token keyword">const</span> vnodeComponentOptions <span class="token operator">=</span> vnode<span class="token punctuation">.</span>componentOptions
  <span class="token keyword">const</span> options<span class="token punctuation">:</span> InternalComponentOptions <span class="token operator">=</span> <span class="token punctuation">{</span>
    _isComponent<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    parent<span class="token punctuation">,</span>
    propsData<span class="token punctuation">:</span> vnodeComponentOptions<span class="token punctuation">.</span>propsData<span class="token punctuation">,</span>
    _componentTag<span class="token punctuation">:</span> vnodeComponentOptions<span class="token punctuation">.</span>tag<span class="token punctuation">,</span>
    _parentVnode<span class="token punctuation">:</span> vnode<span class="token punctuation">,</span>
    _parentListeners<span class="token punctuation">:</span> vnodeComponentOptions<span class="token punctuation">.</span>listeners<span class="token punctuation">,</span>
    _renderChildren<span class="token punctuation">:</span> vnodeComponentOptions<span class="token punctuation">.</span>children<span class="token punctuation">,</span>
    _parentElm<span class="token punctuation">:</span> parentElm <span class="token operator">||</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    _refElm<span class="token punctuation">:</span> refElm <span class="token operator">||</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// check inline-template render functions</span>
  <span class="token keyword">const</span> inlineTemplate <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>inlineTemplate
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>inlineTemplate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    options<span class="token punctuation">.</span>render <span class="token operator">=</span> inlineTemplate<span class="token punctuation">.</span>render
    options<span class="token punctuation">.</span>staticRenderFns <span class="token operator">=</span> inlineTemplate<span class="token punctuation">.</span>staticRenderFns
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">vnodeComponentOptions<span class="token punctuation">.</span>Ctor</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个函数是干什么的呢？我们知道当我们注册一个组件的时候，还是拿上面的例子，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 子组件</span>
<span class="token keyword">var</span> ChildComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">created</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$options<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    components<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// 注册组件</span>
      ChildComponent
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        test<span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>上面的代码中，我们的子组件 <code>ChildComponent</code> 说白了就是一个 <code>json</code> 对象，或者叫做组件选项对象，在父组件的 <code>components</code> 选项中把这个子组件选项对象注册了进去，实际上在 <code>Vue</code> 内部，会首先以子组件选项对象作为参数通过 <code>Vue.extend</code> 函数创建一个子类出来，然后再通过实例化子类来创建子组件，而 <code>createComponentInstanceForVnode</code> 函数的作用，在这里大家就可以简单理解为实例化子组件，只不过这个过程是在虚拟DOM的 <code>patch</code> 算法中进行的，我们后边会详细去讲。我们看 <code>createComponentInstanceForVnode</code> 函数内部有这样一段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> options<span class="token punctuation">:</span> InternalComponentOptions <span class="token operator">=</span> <span class="token punctuation">{</span>
  _isComponent<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  parent<span class="token punctuation">,</span>
  propsData<span class="token punctuation">:</span> vnodeComponentOptions<span class="token punctuation">.</span>propsData<span class="token punctuation">,</span>
  _componentTag<span class="token punctuation">:</span> vnodeComponentOptions<span class="token punctuation">.</span>tag<span class="token punctuation">,</span>
  _parentVnode<span class="token punctuation">:</span> vnode<span class="token punctuation">,</span>
  _parentListeners<span class="token punctuation">:</span> vnodeComponentOptions<span class="token punctuation">.</span>listeners<span class="token punctuation">,</span>
  _renderChildren<span class="token punctuation">:</span> vnodeComponentOptions<span class="token punctuation">.</span>children<span class="token punctuation">,</span>
  _parentElm<span class="token punctuation">:</span> parentElm <span class="token operator">||</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  _refElm<span class="token punctuation">:</span> refElm <span class="token operator">||</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这是实例化子组件时的组件选项，我们发现，第二个值就是 <code>parent</code>，那么这个 <code>parent</code> 是谁呢？它是 <code>createComponentInstanceForVnode</code> 函数的形参，所以我们需要找到 <code>createComponentInstanceForVnode</code> 函数是在哪里调用的，它的调用位置就在 <code>core/vdom/create-component.js</code> 文件内的 <code>componentVNodeHooks</code> 钩子对象的 <code>init</code> 钩子函数内，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// hooks to be invoked on component VNodes during patch</span>
<span class="token keyword">const</span> componentVNodeHooks <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">init</span> <span class="token punctuation">(</span>
    vnode<span class="token punctuation">:</span> VNodeWithData<span class="token punctuation">,</span>
    hydrating<span class="token punctuation">:</span> boolean<span class="token punctuation">,</span>
    parentElm<span class="token punctuation">:</span> <span class="token operator">?</span>Node<span class="token punctuation">,</span>
    refElm<span class="token punctuation">:</span> <span class="token operator">?</span>Node
  <span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token operator">?</span>boolean <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vnode<span class="token punctuation">.</span>componentInstance <span class="token operator">||</span> vnode<span class="token punctuation">.</span>componentInstance<span class="token punctuation">.</span>_isDestroyed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> child <span class="token operator">=</span> vnode<span class="token punctuation">.</span>componentInstance <span class="token operator">=</span> <span class="token function">createComponentInstanceForVnode</span><span class="token punctuation">(</span>
        vnode<span class="token punctuation">,</span>
        activeInstance<span class="token punctuation">,</span>
        parentElm<span class="token punctuation">,</span>
        refElm
      <span class="token punctuation">)</span>
      child<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>hydrating <span class="token operator">?</span> vnode<span class="token punctuation">.</span>elm <span class="token punctuation">:</span> undefined<span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>keepAlive<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// kept-alive components, treat as a patch</span>
      <span class="token keyword">const</span> mountedNode<span class="token punctuation">:</span> any <span class="token operator">=</span> vnode <span class="token comment">// work around flow</span>
      componentVNodeHooks<span class="token punctuation">.</span><span class="token function">prepatch</span><span class="token punctuation">(</span>mountedNode<span class="token punctuation">,</span> mountedNode<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token function">prepatch</span> <span class="token punctuation">(</span>oldVnode<span class="token punctuation">:</span> MountedComponentVNode<span class="token punctuation">,</span> vnode<span class="token punctuation">:</span> MountedComponentVNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token function">insert</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">:</span> MountedComponentVNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token function">destroy</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">:</span> MountedComponentVNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在 <code>init</code> 函数内有这样一段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> child <span class="token operator">=</span> vnode<span class="token punctuation">.</span>componentInstance <span class="token operator">=</span> <span class="token function">createComponentInstanceForVnode</span><span class="token punctuation">(</span>
  vnode<span class="token punctuation">,</span>
  activeInstance<span class="token punctuation">,</span>
  parentElm<span class="token punctuation">,</span>
  refElm
<span class="token punctuation">)</span>
</code></pre></div><p>第二个参数 <code>activeInstance</code> 就是我们要找的 <code>parent</code>，那么 <code>activeInstance</code> 是什么呢？根据文件顶部的 <code>import</code> 语句可知，<code>activeInstance</code> 来自于 <code>core/instance/lifecycle.js</code> 文件，也就是我们正在看的 <code>initLifecycle</code> 函数的上面，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">let</span> activeInstance<span class="token punctuation">:</span> any <span class="token operator">=</span> <span class="token keyword">null</span>
</code></pre></div><p>这个变量将总是保存着当前正在渲染的实例的引用，所以它就是当前实例 <code>components</code> 下注册的子组件的父实例，所以 <code>Vue</code> 实际上就是这样做到自动侦测父级的。</p> <p>这里大家尽量去理解一下，不过如果还是有点懵也没关系，随着我们对 <code>Vue</code> 的深入，慢慢的都会很好消化。上面我们解释了这么多，其实就是想说明白一件事，即 <code>initLifecycle</code> 函数内的代码中的 <code>options.parent</code> 的来历，它有值的原因。</p> <p>所以现在我们初步知道了 <code>options.parent</code> 值的来历，且知道了它的值指向父实例，那么接下来我们继续看代码，还是这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 定义 parent，它引用当前实例的父组件</span>
<span class="token keyword">let</span> parent <span class="token operator">=</span> options<span class="token punctuation">.</span>parent
<span class="token comment">// 如果当前实例有父组件，且当前实例不是抽象的</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>options<span class="token punctuation">.</span>abstract<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 使用 while 循环查找第一个非抽象的父组件</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>abstract <span class="token operator">&amp;&amp;</span> parent<span class="token punctuation">.</span>$parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    parent <span class="token operator">=</span> parent<span class="token punctuation">.</span>$parent
  <span class="token punctuation">}</span>
  <span class="token comment">// 经过上面的 while 循环后，parent 应该是一个非抽象的组件，将它作为当前实例的父级，所以将当前实例 vm 添加到父级的 $children 属性里</span>
  parent<span class="token punctuation">.</span>$children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>拿到父实例 <code>parent</code> 之后，进入一个判断分支，条件是：<code>parent &amp;&amp; !options.abstract</code>，即<em>父实例存在，且当前实例不是抽象的</em>，这里大家可能会有疑问：<em>什么是抽象的实例</em>？实际上 <code>Vue</code> 内部有一些选项是没有暴露给我们的，就比如这里的 <code>abstract</code>，通过设置这个选项为 <code>true</code>，可以指定该组件是抽象的，那么通过该组件创建的实例也都是抽象的，比如：</p> <div class="language-js extra-class"><pre class="language-js"><code>AbsComponents <span class="token operator">=</span> <span class="token punctuation">{</span>
  abstract<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token function">created</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我是一个抽象的组件'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>抽象的组件有什么特点呢？一个最显著的特点就是它们一般不渲染真实DOM，这么说大家可能不理解，我举个例子大家就明白了，我们知道 <code>Vue</code> 内置了一些全局组件比如 <code>keep-alive</code> 或者 <code>transition</code>，我们知道这两个组件它是不会渲染DOM至页面的，但他们依然给我提供了很有用的功能。所以他们就是抽象的组件，我们可以查看一下它的源码，打开 <code>core/components/keep-alive.js</code> 文件，你能看到这样的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'keep-alive'</span><span class="token punctuation">,</span>
  abstract<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以发现，它使用 <code>abstract</code> 选项来声明这是一个抽象组件。除了不渲染真实DOM，抽象组件还有一个特点，就是它们不会出现在父子关系的路径上。这么设计也是合理的，这是由它们的性质所决定的。</p> <p>所以现在大家再回看这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// locate first non-abstract parent (查找第一个非抽象的父组件)</span>
<span class="token comment">// 定义 parent，它引用当前实例的父组件</span>
<span class="token keyword">let</span> parent <span class="token operator">=</span> options<span class="token punctuation">.</span>parent
<span class="token comment">// 如果当前实例有父组件，且当前实例不是抽象的</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>options<span class="token punctuation">.</span>abstract<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 使用 while 循环查找第一个非抽象的父组件</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>abstract <span class="token operator">&amp;&amp;</span> parent<span class="token punctuation">.</span>$parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    parent <span class="token operator">=</span> parent<span class="token punctuation">.</span>$parent
  <span class="token punctuation">}</span>
  <span class="token comment">// 经过上面的 while 循环后，parent 应该是一个非抽象的组件，将它作为当前实例的父级，所以将当前实例 vm 添加到父级的 $children 属性里</span>
  parent<span class="token punctuation">.</span>$children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 设置当前实例的 $parent 属性，指向父级</span>
vm<span class="token punctuation">.</span>$parent <span class="token operator">=</span> parent
<span class="token comment">// 设置 $root 属性，有父级就是用父级的 $root，否则 $root 指向自身</span>
vm<span class="token punctuation">.</span>$root <span class="token operator">=</span> parent <span class="token operator">?</span> parent<span class="token punctuation">.</span>$root <span class="token punctuation">:</span> vm
</code></pre></div><p>如果 <code>options.abstract</code> 为真，那说明当前实例是抽象的，所以并不会走 <code>if</code> 分支的代码，所以会跳过 <code>if</code> 语句块直接设置 <code>vm.$parent</code> 和 <code>vm.$root</code> 的值。跳过 <code>if</code> 语句块的结果将导致该抽象实例不会被添加到父实例的 <code>$children</code> 中。如果 <code>options.abstract</code> 为假，那说明当前实例不是抽象的，是一个普通的组件实例，这个时候就会走 <code>while</code> 循环，那么这个 <code>while</code> 循环是干嘛的呢？我们前面说过，抽象的组件是不能够也不应该作为父级的，所以 <code>while</code> 循环的目的就是沿着父实例链逐层向上寻找到第一个不抽象的实例作为 <code>parent</code>（父级）。并且在找到父级之后将当前实例添加到父实例的 <code>$children</code> 属性中，这样最终的目的就达成了。</p> <p>在上面这段代码执行完毕之后，<code>initLifecycle</code> 函数还负责在当前实例上添加一些属性，即后面要执行的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code>vm<span class="token punctuation">.</span>$children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
vm<span class="token punctuation">.</span>$refs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

vm<span class="token punctuation">.</span>_watcher <span class="token operator">=</span> <span class="token keyword">null</span>
vm<span class="token punctuation">.</span>_inactive <span class="token operator">=</span> <span class="token keyword">null</span>
vm<span class="token punctuation">.</span>_directInactive <span class="token operator">=</span> <span class="token boolean">false</span>
vm<span class="token punctuation">.</span>_isMounted <span class="token operator">=</span> <span class="token boolean">false</span>
vm<span class="token punctuation">.</span>_isDestroyed <span class="token operator">=</span> <span class="token boolean">false</span>
vm<span class="token punctuation">.</span>_isBeingDestroyed <span class="token operator">=</span> <span class="token boolean">false</span>
</code></pre></div><p>其中 <code>$children</code> 和 <code>$refs</code> 都是我们熟悉的实例属性，他们都在 <code>initLifecycle</code> 函数中被初始化，其中 <code>$children</code> 被初始化为一个数组，<code>$refs</code> 被初始化为一个空 <code>json</code> 对象，除此之外，还定义了一些内部使用的属性，大家先混个脸熟，在后面的分析中自然会知道他们的用途，但是不要忘了，既然这些属性是在 <code>initLifecycle</code> 函数中定义的，那么自然会与生命周期有关。这样 <code>initLifecycle</code> 函数我们就分析完毕了，我们回到 <code>_init</code> 函数，看看接下来要做的初始化工作是什么。</p> <h2 id="初始化之-initevents"><a href="#初始化之-initevents" aria-hidden="true" class="header-anchor">#</a> 初始化之 initEvents</h2> <p>在 <code>initLifecycle</code> 函数之后，执行的就是 <code>initEvents</code>，它来自于 <code>core/instance/events.js</code> 文件，打开该文件找到 <code>initEvents</code> 方法，其内容很简短，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">initEvents</span> <span class="token punctuation">(</span>vm<span class="token punctuation">:</span> Component<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>_events <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
  vm<span class="token punctuation">.</span>_hasHookEvent <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token comment">// init parent attached events</span>
  <span class="token keyword">const</span> listeners <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>_parentListeners
  <span class="token keyword">if</span> <span class="token punctuation">(</span>listeners<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">updateComponentListeners</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> listeners<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先在 <code>vm</code> 实例对象上添加两个实例属性 <code>_events</code> 和 <code>_hasHookEvent</code>，其中 <code>_events</code> 被初始化为一个空对象，<code>_hasHookEvent</code> 的初始值为 <code>false</code>。之后将执行这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// init parent attached events</span>
<span class="token keyword">const</span> listeners <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>_parentListeners
<span class="token keyword">if</span> <span class="token punctuation">(</span>listeners<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">updateComponentListeners</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> listeners<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>大家肯定还是有这个疑问：<code>vm.$options._parentListeners</code> 这个 <code>_parentListeners</code> 是哪里来的？细心的同学可能已经注意到了，我们之前看过一个函数叫做 <code>createComponentInstanceForVnode</code>，他在 <code>core/vdom/create-component.js</code> 文件中，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createComponentInstanceForVnode</span> <span class="token punctuation">(</span>
  vnode<span class="token punctuation">:</span> any<span class="token punctuation">,</span> <span class="token comment">// we know it's MountedComponentVNode but flow doesn't</span>
  parent<span class="token punctuation">:</span> any<span class="token punctuation">,</span> <span class="token comment">// activeInstance in lifecycle state</span>
  parentElm<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token operator">?</span>Node<span class="token punctuation">,</span>
  refElm<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token operator">?</span>Node
<span class="token punctuation">)</span><span class="token punctuation">:</span> Component <span class="token punctuation">{</span>
  <span class="token keyword">const</span> vnodeComponentOptions <span class="token operator">=</span> vnode<span class="token punctuation">.</span>componentOptions
  <span class="token keyword">const</span> options<span class="token punctuation">:</span> InternalComponentOptions <span class="token operator">=</span> <span class="token punctuation">{</span>
    _isComponent<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    parent<span class="token punctuation">,</span>
    propsData<span class="token punctuation">:</span> vnodeComponentOptions<span class="token punctuation">.</span>propsData<span class="token punctuation">,</span>
    _componentTag<span class="token punctuation">:</span> vnodeComponentOptions<span class="token punctuation">.</span>tag<span class="token punctuation">,</span>
    _parentVnode<span class="token punctuation">:</span> vnode<span class="token punctuation">,</span>
    _parentListeners<span class="token punctuation">:</span> vnodeComponentOptions<span class="token punctuation">.</span>listeners<span class="token punctuation">,</span>
    _renderChildren<span class="token punctuation">:</span> vnodeComponentOptions<span class="token punctuation">.</span>children<span class="token punctuation">,</span>
    _parentElm<span class="token punctuation">:</span> parentElm <span class="token operator">||</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    _refElm<span class="token punctuation">:</span> refElm <span class="token operator">||</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// check inline-template render functions</span>
  <span class="token keyword">const</span> inlineTemplate <span class="token operator">=</span> vnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>inlineTemplate
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>inlineTemplate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    options<span class="token punctuation">.</span>render <span class="token operator">=</span> inlineTemplate<span class="token punctuation">.</span>render
    options<span class="token punctuation">.</span>staticRenderFns <span class="token operator">=</span> inlineTemplate<span class="token punctuation">.</span>staticRenderFns
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">vnodeComponentOptions<span class="token punctuation">.</span>Ctor</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们发现 <code>_parentListeners</code> 也出现这里，也就是说在创建子组件实例的时候才会有这个参数选项，所以现在我们不做深入讨论，后面自然有机会。</p> <h2 id="初始化之-initrender"><a href="#初始化之-initrender" aria-hidden="true" class="header-anchor">#</a> 初始化之 initRender</h2> <p>在 <code>initEvents</code> 的下面，执行的是 <code>initRender</code> 函数，该函数来自于 <code>core/instance/render.js</code> 文件，我们打开这个文件找到 <code>initRender</code> 函数，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">initRender</span> <span class="token punctuation">(</span>vm<span class="token punctuation">:</span> Component<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>_vnode <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// the root of the child tree</span>
  vm<span class="token punctuation">.</span>_staticTrees <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// v-once cached trees</span>
  <span class="token keyword">const</span> options <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options
  <span class="token keyword">const</span> parentVnode <span class="token operator">=</span> vm<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> options<span class="token punctuation">.</span>_parentVnode <span class="token comment">// the placeholder node in parent tree</span>
  <span class="token keyword">const</span> renderContext <span class="token operator">=</span> parentVnode <span class="token operator">&amp;&amp;</span> parentVnode<span class="token punctuation">.</span>context
  vm<span class="token punctuation">.</span>$slots <span class="token operator">=</span> <span class="token function">resolveSlots</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>_renderChildren<span class="token punctuation">,</span> renderContext<span class="token punctuation">)</span>
  vm<span class="token punctuation">.</span>$scopedSlots <span class="token operator">=</span> emptyObject
  <span class="token comment">// bind the createElement fn to this instance</span>
  <span class="token comment">// so that we get proper render context inside it.</span>
  <span class="token comment">// args order: tag, data, children, normalizationType, alwaysNormalize</span>
  <span class="token comment">// internal version is used by render functions compiled from templates</span>
  vm<span class="token punctuation">.</span><span class="token function-variable function">_c</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">createElement</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
  <span class="token comment">// normalization is always applied for the public version, used in</span>
  <span class="token comment">// user-written render functions.</span>
  vm<span class="token punctuation">.</span><span class="token function-variable function">$createElement</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">createElement</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>

  <span class="token comment">// $attrs &amp; $listeners are exposed for easier HOC creation.</span>
  <span class="token comment">// they need to be reactive so that HOCs using them are always updated</span>
  <span class="token keyword">const</span> parentData <span class="token operator">=</span> parentVnode <span class="token operator">&amp;&amp;</span> parentVnode<span class="token punctuation">.</span>data

  <span class="token comment">/* istanbul ignore else */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">defineReactive</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'$attrs'</span><span class="token punctuation">,</span> parentData <span class="token operator">&amp;&amp;</span> parentData<span class="token punctuation">.</span>attrs <span class="token operator">||</span> emptyObject<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token operator">!</span>isUpdatingChildComponent <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`$attrs is readonly.`</span></span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token function">defineReactive</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'$listeners'</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>_parentListeners <span class="token operator">||</span> emptyObject<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token operator">!</span>isUpdatingChildComponent <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`$listeners is readonly.`</span></span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">defineReactive</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'$attrs'</span><span class="token punctuation">,</span> parentData <span class="token operator">&amp;&amp;</span> parentData<span class="token punctuation">.</span>attrs <span class="token operator">||</span> emptyObject<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token function">defineReactive</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'$listeners'</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>_parentListeners <span class="token operator">||</span> emptyObject<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面是 <code>initRender</code> 函数的全部代码，我们慢慢来看，首先在 <code>Vue</code> 实例对象上添加两个实例属性，即 <code>_vnode</code> 和 <code>_staticTrees</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code>vm<span class="token punctuation">.</span>_vnode <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// the root of the child tree</span>
vm<span class="token punctuation">.</span>_staticTrees <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// v-once cached trees</span>
</code></pre></div><p>并且这两个属性都被初始化为 <code>null</code>，它们会在合适的地方被赋值并使用，到时候我们再讲其作用，现在我们暂且不介绍这两个属性的作用，你只要知道这两句话仅仅是在当前实例对象上添加了两个属性就行了。</p> <p>接着是这样一段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> options <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options
<span class="token keyword">const</span> parentVnode <span class="token operator">=</span> vm<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> options<span class="token punctuation">.</span>_parentVnode <span class="token comment">// the placeholder node in parent tree</span>
<span class="token keyword">const</span> renderContext <span class="token operator">=</span> parentVnode <span class="token operator">&amp;&amp;</span> parentVnode<span class="token punctuation">.</span>context
vm<span class="token punctuation">.</span>$slots <span class="token operator">=</span> <span class="token function">resolveSlots</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>_renderChildren<span class="token punctuation">,</span> renderContext<span class="token punctuation">)</span>
vm<span class="token punctuation">.</span>$scopedSlots <span class="token operator">=</span> emptyObject
</code></pre></div><p>上面这段代码从表面上看很复杂，可以明确地告诉大家，如果你看懂了上面这段代码就意味着你已经知道了 <code>Vue</code> 是如何解析并处理 <code>slot</code> 的了。由于上面这段代码涉及内部选项比较多如：<code>options._parentVnode</code>、<code>options._renderChildren</code> 甚至 <code>parentVnode.context</code>，这些内容牵扯的东西比较多，现在大家对 <code>Vue</code> 的储备还不够，所以我们会在本节的最后阶段补讲，那个时候相信大家理解起来要容易多了。</p> <p>不讲归不讲，但是有一些事儿还是要讲清楚的，比如上面这段代码无论它处理的是什么内容，其结果都是在 <code>Vue</code> 当前实例对象上添加了三个实例属性：</p> <div class="language-js extra-class"><pre class="language-js"><code>vm<span class="token punctuation">.</span>$vnode
vm<span class="token punctuation">.</span>$slots
vm<span class="token punctuation">.</span>$scopedSlots
</code></pre></div><p>我们把这些属性都整理到 <a href="/Blog/knowledge/appendix/vue-ins.html">Vue实例的设计</a> 中。</p> <p>再往下是这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// bind the createElement fn to this instance</span>
<span class="token comment">// so that we get proper render context inside it.</span>
<span class="token comment">// args order: tag, data, children, normalizationType, alwaysNormalize</span>
<span class="token comment">// internal version is used by render functions compiled from templates</span>
vm<span class="token punctuation">.</span><span class="token function-variable function">_c</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">createElement</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token comment">// normalization is always applied for the public version, used in</span>
<span class="token comment">// user-written render functions.</span>
vm<span class="token punctuation">.</span><span class="token function-variable function">$createElement</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">createElement</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
</code></pre></div><p>这段代码在 <code>Vue</code> 实例对象上添加了两个方法：<code>vm._c</code> 和 <code>vm.$createElement</code>，这两个方法实际上是对内部函数 <code>createElement</code> 的包装。其中 <code>vm.$createElement</code> 相信手写过渲染函数的同学都比较熟悉，如下代码：</p> <div class="language-js extra-class"><pre class="language-js"><code>render<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>createElement<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'h2'</span><span class="token punctuation">,</span> <span class="token string">'Title'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们知道，渲染函数的第一个参数是 <code>createElement</code> 函数，该函数用来创建虚拟节点，实际上你也完全可以这么做：</p> <div class="language-js extra-class"><pre class="language-js"><code>render<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$createElement</span><span class="token punctuation">(</span><span class="token string">'h2'</span><span class="token punctuation">,</span> <span class="token string">'Title'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面两段代码是完全等价的。而对于 <code>vm._c</code> 方法，则用于编译器根据模板字符串生成的渲染函数的。<code>vm._c</code> 和 <code>vm.$createElement</code> 的不同之处就在于调用 <code>createElement</code> 函数时传递的第六个参数不同，至于这么做的原因，我们放到后面讲解。有一点需要注意，即 <code>$createElement</code> 看上去像对外暴露的接口，但其实文档上并没有体现。</p> <p>再往下，就是 <code>initRender</code> 函数的最后一段代码了：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// $attrs &amp; $listeners are exposed for easier HOC creation.</span>
<span class="token comment">// they need to be reactive so that HOCs using them are always updated</span>
<span class="token keyword">const</span> parentData <span class="token operator">=</span> parentVnode <span class="token operator">&amp;&amp;</span> parentVnode<span class="token punctuation">.</span>data

<span class="token comment">/* istanbul ignore else */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">defineReactive</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'$attrs'</span><span class="token punctuation">,</span> parentData <span class="token operator">&amp;&amp;</span> parentData<span class="token punctuation">.</span>attrs <span class="token operator">||</span> emptyObject<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token operator">!</span>isUpdatingChildComponent <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`$attrs is readonly.`</span></span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
  <span class="token function">defineReactive</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'$listeners'</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>_parentListeners <span class="token operator">||</span> emptyObject<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token operator">!</span>isUpdatingChildComponent <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`$listeners is readonly.`</span></span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token function">defineReactive</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'$attrs'</span><span class="token punctuation">,</span> parentData <span class="token operator">&amp;&amp;</span> parentData<span class="token punctuation">.</span>attrs <span class="token operator">||</span> emptyObject<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
  <span class="token function">defineReactive</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'$listeners'</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>_parentListeners <span class="token operator">||</span> emptyObject<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面的代码主要作用就是在 <code>Vue</code> 实例对象上定义两个属性：<code>vm.$attrs</code> 以及 <code>vm.$listeners</code>。这两个属性在 <code>Vue</code> 的文档中是有说明的，由于这两个属性的存在使得在 <code>Vue</code> 中创建高阶组件变得更容易，感兴趣的同学可以阅读 <a href="/Blog/knowledge/more/vue-hoc.html">探索Vue高阶组件</a>。</p> <p>我们注意到，在为实例对象定义 <code>$attrs</code> 属性和 <code>$listeners</code> 属性时，使用了 <code>defineReactive</code> 函数，该函数的作用就是为一个对象定义响应式的属性，所以 <code>$attrs</code> 和 <code>$listeners</code> 这两个属性是响应式的，至于 <code>defineReactive</code> 函数的讲解，我们会放到 <code>Vue</code> 的响应系统中讲解。</p> <p>另外，上面的代码中有一个对环境的判断，在非生产环境中调用 <code>defineReactive</code> 函数时传递的第四个参数是一个函数，实际上这个函数是一个自定义的 <code>setter</code>，这个 <code>setter</code> 会在你设置 <code>$attrs</code> 或 <code>$listeners</code> 属性时触发并执行。以 <code>$attrs</code> 属性为例，当你试图设置该属性时，会执行该函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token operator">!</span>isUpdatingChildComponent <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`$attrs is readonly.`</span></span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到，当 <code>!isUpdatingChildComponent</code> 成立时，会提示你 <code>$attrs</code> 是只读属性，你不应该手动设置它的值。同样的，对于 <code>$listeners</code> 属性也做了这样的处理。</p> <p>这里使用到了 <code>isUpdatingChildComponent</code> 变量，根据引用关系，该变量来自于 <code>lifecycle.js</code> 文件，打开 <code>lifecycle.js</code> 文件，可以发现有三个地方使用了这个变量：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 定义 isUpdatingChildComponent，并初始化为 false</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> isUpdatingChildComponent<span class="token punctuation">:</span> boolean <span class="token operator">=</span> <span class="token boolean">false</span>

<span class="token comment">// 省略中间代码 ...</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">updateChildComponent</span> <span class="token punctuation">(</span>
  vm<span class="token punctuation">:</span> Component<span class="token punctuation">,</span>
  propsData<span class="token punctuation">:</span> <span class="token operator">?</span>Object<span class="token punctuation">,</span>
  listeners<span class="token punctuation">:</span> <span class="token operator">?</span>Object<span class="token punctuation">,</span>
  parentVnode<span class="token punctuation">:</span> MountedComponentVNode<span class="token punctuation">,</span>
  renderChildren<span class="token punctuation">:</span> <span class="token operator">?</span>Array<span class="token operator">&lt;</span>VNode<span class="token operator">&gt;</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    isUpdatingChildComponent <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 省略中间代码 ...</span>

  <span class="token comment">// update $attrs and $listeners hash</span>
  <span class="token comment">// these are also reactive so they may trigger child update if the child</span>
  <span class="token comment">// used them during render</span>
  vm<span class="token punctuation">.</span>$attrs <span class="token operator">=</span> parentVnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>attrs <span class="token operator">||</span> emptyObject
  vm<span class="token punctuation">.</span>$listeners <span class="token operator">=</span> listeners <span class="token operator">||</span> emptyObject

  <span class="token comment">// 省略中间代码 ...</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    isUpdatingChildComponent <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面代码是简化后的，可以发现 <code>isUpdatingChildComponent</code> 初始值为 <code>false</code>，只有当 <code>updateChildComponent</code> 函数开始执行的时候会被更新为 <code>true</code>，当 <code>updateChildComponent</code> 执行结束时又将 <code>isUpdatingChildComponent</code> 的值还原为 <code>false</code>，这是因为 <code>updateChildComponent</code> 函数需要更新实例对象的 <code>$attrs</code> 和 <code>$listeners</code> 属性，所以此时是不需要提示 <code>$attrs</code> 和 <code>$listeners</code> 是只读属性的。</p> <p>最后，对于大家来讲，现在了解这些知识就足够了，至于 <code>$attrs</code> 和 <code>$listeners</code> 这两个属性的值到底是什么，等我们讲解虚拟DOM的时候再回来说明，这样大家更容易理解。</p> <h2 id="生命周期钩子的实现方式"><a href="#生命周期钩子的实现方式" aria-hidden="true" class="header-anchor">#</a> 生命周期钩子的实现方式</h2> <p>在 <code>initRender</code> 函数执行完毕后，是这样一段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeCreate'</span><span class="token punctuation">)</span>
<span class="token function">initInjections</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// resolve injections before data/props</span>
<span class="token function">initState</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token function">initProvide</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// resolve provide after data/props</span>
<span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'created'</span><span class="token punctuation">)</span>
</code></pre></div><p>可以发现，<code>initInjections(vm)</code>、<code>initState(vm)</code> 以及 <code>initProvide(vm)</code> 被包裹在两个 <code>callHook</code> 函数调用的语句中。那么 <code>callHook</code> 函数的作用是什么呢？正如它的名字一样，<code>callHook</code> 函数的作用是调用生命周期钩子函数。根据引用关系可知 <code>callHook</code> 函数来自于 <code>lifecycle.js</code> 文件，打开该文件找到 <code>callHook</code> 函数如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">callHook</span> <span class="token punctuation">(</span>vm<span class="token punctuation">:</span> Component<span class="token punctuation">,</span> hook<span class="token punctuation">:</span> string<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// #7573 disable dep collection when invoking lifecycle hooks</span>
  <span class="token function">pushTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> handlers <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">[</span>hook<span class="token punctuation">]</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>handlers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> handlers<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        handlers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">handleError</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> vm<span class="token punctuation">,</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hook<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> hook`</span></span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_hasHookEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'hook:'</span> <span class="token operator">+</span> hook<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">popTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以上是 <code>callHook</code> 函数的全部代码，它接收两个参数：实例对象和要调用的生命周期钩子的名称。接下来我们就看看 <code>callHook</code> 是如何实现的。</p> <p>大家可能注意到了 <code>callHook</code> 函数体的代码以 <code>pushTarget()</code> 开头，并以 <code>popTarget()</code> 结尾，这里我们暂且不讲这么做的目的，这其实是为了避免在某些生命周期钩子中使用 <code>props</code> 数据导致收集冗余的依赖，我们在 <code>Vue</code> 响应系统的章节会回过头来仔细给大家讲解。下面我们开始分析 <code>callHook</code> 函数的代码的中间部分，首先获取要调用的生命周期钩子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> handlers <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">[</span>hook<span class="token punctuation">]</span>
</code></pre></div><p>比如 <code>callHook(vm, created)</code>，那么上面的代码就相当于：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> handlers <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>created
</code></pre></div><p>在 <a href="/Blog/knowledge/js/5vue-merge.html">Vue选项的合并</a> 一节中我们讲过，对于生命周期钩子选项最终会被合并处理成一个数组，所以得到的 <code>handlers</code> 就是对应生命周期钩子的数组。接着执行的是这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>handlers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> handlers<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      handlers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">handleError</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> vm<span class="token punctuation">,</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hook<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> hook`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>由于开发者在编写组件时未必会写生命周期钩子，所以获取到的 <code>handlers</code> 可能不存在，所以使用 <code>if</code> 语句进行判断，只有当 <code>handlers</code> 存在的时候才对 <code>handlers</code> 进行遍历，<code>handlers</code> 数组的元素就是生命周期钩子函数，所以直接执行即可：</p> <div class="language-js extra-class"><pre class="language-js"><code>handlers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
</code></pre></div><p>为了保证生命周期钩子函数内可以通过 <code>this</code> 访问实例对象，所以使用 <code>.call(vm)</code> 执行这些函数。另外由于生命周期钩子函数的函数体是开发者编写的，为了捕获可能出现的错误，使用 <code>try...catch</code> 语句块，并在 <code>catch</code> 语句块内使用 <code>handleError</code> 处理错误信息。其中 <code>handleError</code> 来自于 <code>core/util/error.js</code> 文件，大家可以在附录 <a href="/Blog/knowledge/appendix/core-util.html">core/util 目录下的工具方法全解</a> 中查看关于 <code>handleError</code> 的讲解。</p> <p>所以我们发现，对于生命周期钩子的调用，其实就是通过 <code>this.$options</code> 访问处理过的对应的生命周期钩子函数数组，遍历并执行它们。原理还是很简单的。</p> <p>我们回过头来再看一下这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeCreate'</span><span class="token punctuation">)</span>
<span class="token function">initInjections</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// resolve injections before data/props</span>
<span class="token function">initState</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token function">initProvide</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// resolve provide after data/props</span>
<span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'created'</span><span class="token punctuation">)</span>
</code></pre></div><p>现在大家应该知道，<code>beforeCreate</code> 以及 <code>created</code> 这两个生命周期钩子的调用时机了。其中 <code>initState</code> 包括了：<code>initProps</code>、<code>initMethods</code>、<code>initData</code>、<code>initComputed</code> 以及 <code>initWatch</code>。所以当 <code>beforeCreate</code> 钩子被调用时，所有与 <code>props</code>、<code>methods</code>、<code>data</code>、<code>computed</code> 以及 <code>watch</code> 相关的内容都不能使用，当然了 <code>inject/provide</code> 也是不可用的。</p> <p>作为对立面，<code>created</code> 生命周期钩子则恰恰是等待 <code>initInjections</code>、<code>initState</code> 以及 <code>initProvide</code> 执行完毕之后才被调用，所以在 <code>created</code> 钩子中，是完全能够使用以上提到的内容的。但由于此时还没有任何挂载的操作，所以在 <code>created</code> 中是不能访问DOM的，即不能访问 <code>$el</code>。</p> <p>最后我们注意到 <code>callHook</code> 函数的最后有这样一段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_hasHookEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'hook:'</span> <span class="token operator">+</span> hook<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其中 <code>vm._hasHookEvent</code> 是在 <code>initEvents</code> 函数中定义的，它的作用是判断是否存在<strong>生命周期钩子的事件侦听器</strong>，初始化值为 <code>false</code> 代表没有，当组件检测到存在<strong>生命周期钩子的事件侦听器</strong>时，会将 <code>vm._hasHookEvent</code> 设置为 <code>true</code>。那么问题来了，什么叫做<strong>生命周期钩子的事件侦听器</strong>呢？大家可能不知道，其实 <code>Vue</code> 是可以这么玩儿的：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span>
  <span class="token attr-name"><span class="token namespace">@hook:</span>beforeCreate</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>handleChildBeforeCreate<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name"><span class="token namespace">@hook:</span>created</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>handleChildCreated<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name"><span class="token namespace">@hook:</span>mounted</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>handleChildMounted<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name"><span class="token namespace">@hook:</span>生命周期钩子</span>
 <span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>如上代码可以使用 <code>hook:</code> 加 <code>生命周期钩子名称</code> 的方式来监听组件相应的生命周期事件。这是 <code>Vue</code> 官方文档上没有体现的，但你确实可以这么用，不过除非你对 <code>Vue</code> 非常了解，否则不建议使用。</p> <p>正是为了实现这个功能，才有了这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_hasHookEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'hook:'</span> <span class="token operator">+</span> hook<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>另外大家可能会疑惑，<code>vm._hasHookEvent</code> 是在什么时候被设置为 <code>true</code> 的呢？或者换句话说，<code>Vue</code> 是如何检测是否存在生命周期事件侦听器的呢？对于这个问题等我们在讲解 <code>Vue</code> 事件系统时自然会知道。</p> <h2 id="vue-的初始化之-initstate"><a href="#vue-的初始化之-initstate" aria-hidden="true" class="header-anchor">#</a> Vue 的初始化之 initState</h2> <p>实际上根据如下代码所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeCreate'</span><span class="token punctuation">)</span>
<span class="token function">initInjections</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// resolve injections before data/props</span>
<span class="token function">initState</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token function">initProvide</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// resolve provide after data/props</span>
<span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'created'</span><span class="token punctuation">)</span>
</code></pre></div><p>可以看到在 <code>initState</code> 函数执行之前，先执行了 <code>initInjections</code> 函数，也就是说 <code>inject</code> 选项要更早被初始化，不过由于初始化 <code>inject</code> 选项的时候涉及到 <code>defineReactive</code> 函数，并且调用了 <code>toggleObserving</code> 函数操作了用于控制是否应该转换为响应式属性的状态标识 <code>observerState.shouldConvert</code>，所以我们决定先讲解 <code>initState</code>，之后再来讲解 <code>initInjections</code> 和 <code>initProvide</code>，这才是一个合理的顺序，并且从 <code>Vue</code> 的时间线上来看 <code>inject/provide</code> 选项确实是后来才添加的。</p> <p>所以我们打开 <code>core/instance/state.js</code> 文件，找到 <code>initState</code> 函数，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">initState</span> <span class="token punctuation">(</span>vm<span class="token punctuation">:</span> Component<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>_watchers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">const</span> opts <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token function">initProps</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>methods<span class="token punctuation">)</span> <span class="token function">initMethods</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>methods<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">initData</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">observe</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* asRootData */</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>computed<span class="token punctuation">)</span> <span class="token function">initComputed</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>computed<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>watch <span class="token operator">&amp;&amp;</span> opts<span class="token punctuation">.</span>watch <span class="token operator">!==</span> nativeWatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">initWatch</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>watch<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以上是 <code>initState</code> 函数的全部代码，我们慢慢来看，首先在 <code>Vue</code> 实例对象添加一个属性 <code>vm._watchers = []</code>，其初始值是一个数组，这个数组将用来存储所有该组件实例的 <code>watcher</code> 对象。随后定义了常量 <code>opts</code>，它是 <code>vm.$options</code> 的引用。接着执行了如下两句代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token function">initProps</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>props<span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>methods<span class="token punctuation">)</span> <span class="token function">initMethods</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>methods<span class="token punctuation">)</span>
</code></pre></div><p>如果 <code>opts.props</code> 存在，即选项中有 <code>props</code>，那么就调用 <code>initProps</code> 初始化 <code>props</code> 选项。同样的，如果 <code>opts.methods</code> 存在，则调用 <code>initMethods</code> 初始化 <code>methods</code> 选项。</p> <p>再往下执行的是这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">initData</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token function">observe</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* asRootData */</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先判断 <code>data</code> 选项是否存在，如果存在则调用 <code>initData</code> 初始化 <code>data</code> 选项，如果不存在则直接调用 <code>observe</code> 函数观测一个空对象：<code>{}</code>。</p> <p>最后执行的是如下这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>computed<span class="token punctuation">)</span> <span class="token function">initComputed</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>computed<span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>watch <span class="token operator">&amp;&amp;</span> opts<span class="token punctuation">.</span>watch <span class="token operator">!==</span> nativeWatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">initWatch</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> opts<span class="token punctuation">.</span>watch<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>采用同样的方式初始化 <code>computed</code> 选项，但是对于 <code>watch</code> 选项仅仅判断 <code>opts.watch</code> 是否存在是不够的，还要判断 <code>opts.watch</code> 是不是原生的 <code>watch</code> 对象。前面的章节中我们提到过，这是因为在 <code>Firefox</code> 中原生提供了 <code>Object.prototype.watch</code> 函数，所以即使没有 <code>opts.watch</code> 选项，如果在火狐浏览器中依然能够通过原型链访问到原生的 <code>Object.prototype.watch</code>。但这其实不是我们想要的结果，所以这里加了一层判断避免把原生 <code>watch</code> 函数误认为是我们预期的 <code>opts.watch</code> 选项。之后才会调用 <code>initWatch</code> 函数初始化 <code>opts.watch</code> 选项。</p> <p>通过阅读 <code>initState</code> 函数，我们可以发现 <code>initState</code> 其实是很多选项初始化的汇总，包括：<code>props</code>、<code>methods</code>、<code>data</code>、<code>computed</code> 和 <code>watch</code> 等。并且我们注意到 <code>props</code> 选项的初始化要早于 <code>data</code> 选项的初始化，那么这是不是可以使用 <code>props</code> 初始化 <code>data</code> 数据的原因呢？答案是：“是的”。接下来我们就深入讲解这些初始化工作都做了什么事情。下一章节我们将重点讲解 <code>Vue</code> 初始化中的关键一步：<strong>数据响应系统</strong>。</p></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/Blog/knowledge/js/5vue-merge.html" class="prev">
          Vue 选项的合并
        </a></span> <span class="next"><a href="/Blog/knowledge/js/7vue-reactive.html">
          揭开数据响应系统的面纱
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/Blog/assets/js/app.cdba929c.js" defer></script><script src="/Blog/assets/js/12.c3f56d7b.js" defer></script>
  </body>
</html>
