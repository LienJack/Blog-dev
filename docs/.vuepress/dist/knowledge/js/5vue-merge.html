<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 选项的合并 | 个人主页</title>
    <meta name="description" content="lien的知识库">
    
    
    <link rel="preload" href="/Blog/assets/css/0.styles.a52f7505.css" as="style"><link rel="preload" href="/Blog/assets/js/app.cdba929c.js" as="script"><link rel="preload" href="/Blog/assets/js/11.68cb89c6.js" as="script"><link rel="prefetch" href="/Blog/assets/js/10.ffaea7b6.js"><link rel="prefetch" href="/Blog/assets/js/12.c3f56d7b.js"><link rel="prefetch" href="/Blog/assets/js/13.c9c51a46.js"><link rel="prefetch" href="/Blog/assets/js/14.e84b061f.js"><link rel="prefetch" href="/Blog/assets/js/15.3b4cc0f6.js"><link rel="prefetch" href="/Blog/assets/js/16.96c6021e.js"><link rel="prefetch" href="/Blog/assets/js/17.e2982de3.js"><link rel="prefetch" href="/Blog/assets/js/18.d9a15a58.js"><link rel="prefetch" href="/Blog/assets/js/19.d99e73c0.js"><link rel="prefetch" href="/Blog/assets/js/2.f408895a.js"><link rel="prefetch" href="/Blog/assets/js/20.c5f4581d.js"><link rel="prefetch" href="/Blog/assets/js/21.3438a0b8.js"><link rel="prefetch" href="/Blog/assets/js/22.015a194d.js"><link rel="prefetch" href="/Blog/assets/js/23.efaebbb4.js"><link rel="prefetch" href="/Blog/assets/js/24.585b0621.js"><link rel="prefetch" href="/Blog/assets/js/25.ce34ef53.js"><link rel="prefetch" href="/Blog/assets/js/26.3ba8840d.js"><link rel="prefetch" href="/Blog/assets/js/3.9a2081a3.js"><link rel="prefetch" href="/Blog/assets/js/4.96ff7512.js"><link rel="prefetch" href="/Blog/assets/js/5.0b98e5f3.js"><link rel="prefetch" href="/Blog/assets/js/6.a43352fb.js"><link rel="prefetch" href="/Blog/assets/js/7.d7e26d93.js"><link rel="prefetch" href="/Blog/assets/js/8.b6302fc1.js"><link rel="prefetch" href="/Blog/assets/js/9.39a6e0ed.js">
    <link rel="stylesheet" href="/Blog/assets/css/0.styles.a52f7505.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Blog/" class="home-link router-link-active"><!----> <span class="site-name">个人主页</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Blog/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">知识</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Blog/knowledge/js/" class="nav-link router-link-active">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/Blog/lien-ui/" class="nav-link">UI框架</a></li><li class="dropdown-item"><!----> <a href="/Blog/about/" class="nav-link">关于</a></li></ul></div></div><div class="nav-item"><a href="/Blog/work/" class="nav-link">工程</a></div><div class="nav-item"><a href="/Blog/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="https://github.com/LienJack/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Blog/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">知识</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Blog/knowledge/js/" class="nav-link router-link-active">JavaScript</a></li><li class="dropdown-item"><!----> <a href="/Blog/lien-ui/" class="nav-link">UI框架</a></li><li class="dropdown-item"><!----> <a href="/Blog/about/" class="nav-link">关于</a></li></ul></div></div><div class="nav-item"><a href="/Blog/work/" class="nav-link">工程</a></div><div class="nav-item"><a href="/Blog/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="https://github.com/LienJack/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>javascript</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/Blog/knowledge/js/" class="sidebar-link">了解js</a></li><li><a href="/Blog/knowledge/js/1start-learn.html" class="sidebar-link">了解 Vue 这个项目</a></li><li><a href="/Blog/knowledge/js/2vue-constructor.html" class="sidebar-link">Vue 构造函数</a></li><li><a href="/Blog/knowledge/js/3vue-example.html" class="sidebar-link">以一个例子为线索</a></li><li><a href="/Blog/knowledge/js/4vue-normalize.html" class="sidebar-link">Vue 选项的规范化</a></li><li><a href="/Blog/knowledge/js/5vue-merge.html" class="active sidebar-link">Vue 选项的合并</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Blog/knowledge/js/5vue-merge.html#选项-el、propsdata-的合并策略" class="sidebar-link">选项 el、propsData 的合并策略</a></li><li class="sidebar-sub-header"><a href="/Blog/knowledge/js/5vue-merge.html#选项-data-的合并策略" class="sidebar-link">选项 data 的合并策略</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Blog/knowledge/js/5vue-merge.html#一、为什么最终-strats-data-会被处理成一个函数？" class="sidebar-link">一、为什么最终 strats.data 会被处理成一个函数？</a></li><li class="sidebar-sub-header"><a href="/Blog/knowledge/js/5vue-merge.html#二、为什么不在合并阶段就把数据合并好，而是要等到初始化的时候再合并数据？" class="sidebar-link">二、为什么不在合并阶段就把数据合并好，而是要等到初始化的时候再合并数据？</a></li><li class="sidebar-sub-header"><a href="/Blog/knowledge/js/5vue-merge.html#三、你可以这么做。" class="sidebar-link">三、你可以这么做。</a></li></ul></li><li class="sidebar-sub-header"><a href="/Blog/knowledge/js/5vue-merge.html#生命周期钩子选项的合并策略" class="sidebar-link">生命周期钩子选项的合并策略</a></li><li class="sidebar-sub-header"><a href="/Blog/knowledge/js/5vue-merge.html#资源-assets-选项的合并策略" class="sidebar-link">资源(assets)选项的合并策略</a></li><li class="sidebar-sub-header"><a href="/Blog/knowledge/js/5vue-merge.html#选项-watch-的合并策略" class="sidebar-link">选项 watch 的合并策略</a></li><li class="sidebar-sub-header"><a href="/Blog/knowledge/js/5vue-merge.html#选项-props、methods、inject、computed-的合并策略" class="sidebar-link">选项 props、methods、inject、computed 的合并策略</a></li><li class="sidebar-sub-header"><a href="/Blog/knowledge/js/5vue-merge.html#选项-provide-的合并策略" class="sidebar-link">选项 provide 的合并策略</a></li><li class="sidebar-sub-header"><a href="/Blog/knowledge/js/5vue-merge.html#选项处理小结" class="sidebar-link">选项处理小结</a></li><li class="sidebar-sub-header"><a href="/Blog/knowledge/js/5vue-merge.html#再看-mixins-和-extends" class="sidebar-link">再看 mixins 和 extends</a></li></ul></li><li><a href="/Blog/knowledge/js/6vue-init-start.html" class="sidebar-link">Vue 的初始化之开篇</a></li><li><a href="/Blog/knowledge/js/7vue-reactive.html" class="sidebar-link">揭开数据响应系统的面纱</a></li><li><a href="/Blog/knowledge/js/8vue-reactive-dep-watch.html" class="sidebar-link">渲染函数的观察者与进阶的数据响应系统</a></li><li><a href="/Blog/knowledge/js/9vue-state-init.html" class="sidebar-link">其他重要选项的初始化及实现</a></li><li><a href="/Blog/knowledge/js/80vue-compiler-start.html" class="sidebar-link">Vue 的编译器初探</a></li><li><a href="/Blog/knowledge/js/81vue-lexical-analysis.html" class="sidebar-link">词法分析 - 为生成AST做准备</a></li><li><a href="/Blog/knowledge/js/82vue-parsing.html" class="sidebar-link">句法分析 - 生成真正的AST(一)</a></li><li><a href="/Blog/knowledge/js/83vue-parsing-2.html" class="sidebar-link">句法分析 - 生成真正的AST(二)</a></li><li><a href="/Blog/knowledge/js/84vue-codegen.html" class="sidebar-link">编译器之代码的生成</a></li><li><a href="/Blog/knowledge/js/85vue-vdom.html" class="sidebar-link">虚拟DOM解析</a></li><li><a href="/Blog/knowledge/js/86vue-vdom-patch.html" class="sidebar-link">虚拟DOM补丁算法详解</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="vue-选项的合并"><a href="#vue-选项的合并" aria-hidden="true" class="header-anchor">#</a> Vue 选项的合并</h1> <p>上一章节我们了解了 <code>Vue</code> 对选项的规范化，而接下来才是真正的合并阶段，我们继续看 <code>mergeOptions</code> 函数的代码，接下来的一段代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> key
<span class="token keyword">for</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">mergeField</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> child<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">mergeField</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">mergeField</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> strat <span class="token operator">=</span> strats<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">||</span> defaultStrat
  options<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">strat</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> child<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> vm<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> options
</code></pre></div><p>这段代码的第一句和最后一句说明了 <code>mergeOptions</code> 函数的的确确返回了一个新的对象，因为第一句代码定义了一个常量 <code>options</code>，而最后一句代码将其返回，所以我们自然可以预估到中间的代码是在充实 <code>options</code> 常量，而 <code>options</code> 常量就应该是最终合并之后的选项，我们看看它是怎么产生的。</p> <p>首先我们明确一下代码结构，这里有两个 <code>for in</code> 循环以及一个名字叫 <code>mergeField</code> 的函数，而且我们可以发现这两个 <code>for in</code> 循环中都调用了 <code>mergeField</code> 函数。我们先看第一段 <code>for in</code> 代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">mergeField</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这段 <code>for in</code> 用来遍历 <code>parent</code>，并且将 <code>parent</code> 对象的键作为参数传递给 <code>mergeField</code> 函数，大家应该知道这里的 <code>key</code> 是什么，假如 <code>parent</code> 就是 <code>Vue.options</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span>options <span class="token operator">=</span> <span class="token punctuation">{</span>
  components<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      KeepAlive<span class="token punctuation">,</span>
      Transition<span class="token punctuation">,</span>
      TransitionGroup
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  directives<span class="token punctuation">:</span><span class="token punctuation">{</span>
      model<span class="token punctuation">,</span>
      show
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  filters<span class="token punctuation">:</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  _base<span class="token punctuation">:</span> Vue
<span class="token punctuation">}</span>
</code></pre></div><p>那么 <code>key</code> 就应该分别是：<code>components</code>、<code>directives</code>、<code>filters</code> 以及 <code>_base</code>，除了 <code>_base</code> 其他的字段都可以理解为是 <code>Vue</code> 提供的选项的名字。</p> <p>而第二段 <code>for in</code> 代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> child<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">mergeField</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其遍历的是 <code>child</code> 对象，并且多了一个判断：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>其中 <code>hasOwn</code> 函数来自于 <code>shared/util.js</code> 文件，可以在 <a href="/Blog/knowledge/appendix/shared-util.html">shared/util.js 文件工具方法全解</a> 中查看其详解，其作用是用来判断一个属性是否是对象自身的属性(不包括原型上的)。所以这个判断语句的意思是，如果 <code>child</code> 对象的键也在 <code>parent</code> 上出现，那么就不要再调用 <code>mergeField</code> 了，因为在上一个 <code>for in</code> 循环中已经调用过了，这就避免了重复调用。</p> <p>总之这两个 <code>for in</code> 循环的目的就是使用在 <code>parent</code> 或者 <code>child</code> 对象中出现的 <code>key(即选项的名字)</code> 作为参数调用 <code>mergeField</code> 函数，真正合并的操作实际在 <code>mergeField</code> 函数中。</p> <p><code>mergeField</code> 代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mergeField</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> strat <span class="token operator">=</span> strats<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">||</span> defaultStrat
  options<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">strat</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> child<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> vm<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>mergeField</code> 函数只有两句代码，第一句代码定义了一个常量 <code>strat</code>，它的值是通过指定的 <code>key</code> 访问 <code>strats</code> 对象得到的，而当访问的属性不存在时，则使用 <code>defaultStrat</code> 作为值。</p> <p>这里我们就要明确了，<code>strats</code> 是什么？想弄明白这个问题，我们需要从整体角度去看一下 <code>options.js</code> 文件，首先看文件顶部的一堆 <code>import</code> 语句下的第一句代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */</span>
<span class="token keyword">const</span> strats <span class="token operator">=</span> config<span class="token punctuation">.</span>optionMergeStrategies
</code></pre></div><p>这句代码就定义了 <code>strats</code> 变量，且它是一个常量，这个常量的值为 <code>config.optionMergeStrategies</code>，这个 <code>config</code> 对象是全局配置对象，来自于 <code>core/config.js</code> 文件，此时 <code>config.optionMergeStrategies</code> 还只是一个空的对象。注意一下这里的一段注释：<em>选项覆盖策略是处理如何将父选项值和子选项值合并到最终值的函数</em>。也就是说 <code>config.optionMergeStrategies</code> 是一个合并选项的策略对象，这个对象下包含很多函数，这些函数就可以认为是合并特定选项的策略。这样不同的选项使用不同的合并策略，如果你使用自定义选项，那么你也可以自定义该选项的合并策略，只需要在 <code>Vue.config.optionMergeStrategies</code> 对象上添加与自定义选项同名的函数就行。而这就是 <code>Vue</code> 文档中提过的全局配置：<a href="https://vuejs.org/v2/api/#optionMergeStrategies" target="_blank" rel="noopener noreferrer">optionMergeStrategies<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h2 id="选项-el、propsdata-的合并策略"><a href="#选项-el、propsdata-的合并策略" aria-hidden="true" class="header-anchor">#</a> 选项 el、propsData 的合并策略</h2> <p>那么接下来我们就看看这个选项合并策略对象都有哪些策略，首先是下面这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Options with restrictions
 */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  strats<span class="token punctuation">.</span>el <span class="token operator">=</span> strats<span class="token punctuation">.</span><span class="token function-variable function">propsData</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>parent<span class="token punctuation">,</span> child<span class="token punctuation">,</span> vm<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">warn</span><span class="token punctuation">(</span>
        <span class="token template-string"><span class="token string">`option &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; can only be used during instance `</span></span> <span class="token operator">+</span>
        <span class="token string">'creation with the `new` keyword.'</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">defaultStrat</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> child<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>非生产环境下在 <code>strats</code> 策略对象上添加两个策略(两个属性)分别是 <code>el</code> 和 <code>propsData</code>，且这两个属性的值是一个函数。通过这两个属性的名字可知，这两个策略函数是用来合并 <code>el</code> 选项和 <code>propsData</code> 选项的。与其说“合并”不如说“处理”，因为其本质上并没有做什么合并工作。那么我们看看这个策略函数的具体内容，了解一下它是怎么处理 <code>el</code> 和 <code>propsData</code> 选项的。</p> <p>首先是一段 <code>if</code> 判断分支，判断是否有传递 <code>vm</code> 参数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">warn</span><span class="token punctuation">(</span>
    <span class="token template-string"><span class="token string">`option &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot; can only be used during instance `</span></span> <span class="token operator">+</span>
    <span class="token string">'creation with the `new` keyword.'</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果没有传递这个参数，那么便会给你一个警告，提示你 <code>el</code> 选项或者 <code>propsData</code> 选项只能在使用 <code>new</code> 操作符创建实例的时候可用。比如下面的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 子组件</span>
<span class="token keyword">var</span> ChildComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
  el<span class="token punctuation">:</span> <span class="token string">'#app2'</span><span class="token punctuation">,</span>
  created<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child component created'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 父组件</span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    test<span class="token punctuation">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  components<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    ChildComponent
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>上面的代码中我们在父组件中使用 <code>el</code> 选项，这并没有什么问题，但是在子组件中也使用了 <code>el</code> 选项，这就会得到如上警告。这说明了一个问题，即在策略函数中如果拿不到 <code>vm</code> 参数，那说明处理的是子组件选项。所以问题来了，为什么通过判断 <code>vm</code> 是否存在，就能判断出是否是子组件呢？那首先我们要搞清楚策略函数中的 <code>vm</code> 参数是哪里来的。首先我们还是看一下 <code>mergeField</code> 函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mergeField</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> strat <span class="token operator">=</span> strats<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">||</span> defaultStrat
  options<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">strat</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> child<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> vm<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>函数体的第二句代码中在调用策略函数的时候，第三个参数 <code>vm</code> 就是我们在策略函数中使用的那个 <code>vm</code>，那么这里的 <code>vm</code> 是谁呢？它实际上是从 <code>mergeOptions</code> 函数透传过来的，因为 <code>mergeOptions</code> 函数的第三个参数就是 <code>vm</code>。我们知道在 <code>_init</code> 方法中调用 <code>mergeOptions</code> 函数时第三个参数就是当前 <code>Vue</code> 实例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// _init 方法中调用 mergeOptions 函数，第三个参数是 Vue 实例</span>
vm<span class="token punctuation">.</span>$options <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>
  <span class="token function">resolveConstructorOptions</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">,</span>
  options <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  vm
<span class="token punctuation">)</span>
</code></pre></div><p>所以我们可以理解为：策略函数中的 <code>vm</code> 来自于 <code>mergeOptions</code> 函数的第三个参数。所以当调用 <code>mergeOptions</code> 函数且不传递第三个参数的时候，那么在策略函数中就拿不到 <code>vm</code> 参数。所以我们可以猜测到一件事，那就是 <code>mergeOptions</code> 函数除了在 <code>_init</code> 方法中被调用之外，还在其他地方被调用，且没有传递第三个参数。那么到底是在哪里被调用的呢？这里可以先明确地告诉大家，就是在 <code>Vue.extend</code> 方法中被调用的，大家可以打开 <code>core/global-api/extend.js</code> 文件找到 <code>Vue.extend</code> 方法，其中有这么一段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code>Sub<span class="token punctuation">.</span>options <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>
  Super<span class="token punctuation">.</span>options<span class="token punctuation">,</span>
  extendOptions
<span class="token punctuation">)</span>
</code></pre></div><p>可以发现，此时调用 <code>mergeOptions</code> 函数就没有传递第三个参数，也就是说通过 <code>Vue.extend</code> 创建子类的时候 <code>mergeOptions</code> 会被调用，此时策略函数就拿不到第三个参数。</p> <p>所以现在就比较明朗了，在策略函数中通过判断是否存在 <code>vm</code> 就能够得知 <code>mergeOptions</code> 是在实例化时调用(使用 <code>new</code> 操作符走 <code>_init</code> 方法)还是在继承时调用(<code>Vue.extend</code>)，而子组件的实现方式就是通过实例化子类完成的，子类又是通过 <code>Vue.extend</code> 创造出来的，所以我们就能通过对 <code>vm</code> 的判断而得知是否是子组件了。</p> <p>所以最终的结论就是：<em>如果策略函数中拿不到 <code>vm</code> 参数，那么处理的就是子组件的选项</em>，花了大量的口舌解释了策略函数中判断 <code>vm</code> 的意义，实际上这些解释是必要的。</p> <p>我们接着看 <code>strats.el</code> 和 <code>strats.propsData</code> 策略函数的代码，在 <code>if</code> 判断分支下面，直接调用了 <code>defaultStrat</code> 函数并返回：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">return</span> <span class="token function">defaultStrat</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> child<span class="token punctuation">)</span>
</code></pre></div><p><code>defaultStrat</code> 函数就定义在 <code>options.js</code> 文件内，源码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Default strategy.
 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">defaultStrat</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>parentVal<span class="token punctuation">:</span> any<span class="token punctuation">,</span> childVal<span class="token punctuation">:</span> any<span class="token punctuation">)</span><span class="token punctuation">:</span> any <span class="token punctuation">{</span>
  <span class="token keyword">return</span> childVal <span class="token operator">===</span> undefined
    <span class="token operator">?</span> parentVal
    <span class="token punctuation">:</span> childVal
<span class="token punctuation">}</span>
</code></pre></div><p>实际上 <code>defaultStrat</code> 函数就如同它的名字一样，它是一个默认的策略，当一个选项不需要特殊处理的时候就使用默认的合并策略，它的逻辑很简单：只要子选项不是 <code>undefined</code> 那么就是用子选项，否则使用父选项。</p> <p>但是大家还要注意一点，<code>strats.el</code> 和 <code>strats.propsData</code> 这两个策略函数是只有在非生产环境才有的，在生产环境下访问这两个函数将会得到 <code>undefined</code>，那这个时候 <code>mergeField</code> 函数的第一句代码就起作用了：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 当一个选项没有对应的策略函数时，使用默认策略</span>
<span class="token keyword">const</span> strat <span class="token operator">=</span> strats<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">||</span> defaultStrat
</code></pre></div><p>所以在生产环境将直接使用默认的策略函数 <code>defaultStrat</code> 来处理 <code>el</code> 和 <code>propsData</code> 这两个选项。</p> <h2 id="选项-data-的合并策略"><a href="#选项-data-的合并策略" aria-hidden="true" class="header-anchor">#</a> 选项 data 的合并策略</h2> <p>下面我们接着按照顺序看 <code>options.js</code> 文件的代码，接下来定义了两个函数：<code>mergeData</code> 以及 <code>mergeDataOrFn</code>，我们暂且不关注这两个函数的作用。暂且跳过继续看下面的代码，接下来的代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>strats<span class="token punctuation">.</span><span class="token function-variable function">data</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>
  parentVal<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  childVal<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  vm<span class="token operator">?</span><span class="token punctuation">:</span> Component
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token operator">?</span>Function <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>childVal <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> childVal <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span>
        <span class="token string">'The &quot;data&quot; option should be a function '</span> <span class="token operator">+</span>
        <span class="token string">'that returns a per-instance value in component '</span> <span class="token operator">+</span>
        <span class="token string">'definitions.'</span><span class="token punctuation">,</span>
        vm
      <span class="token punctuation">)</span>

      <span class="token keyword">return</span> parentVal
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">mergeDataOrFn</span><span class="token punctuation">(</span>parentVal<span class="token punctuation">,</span> childVal<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token function">mergeDataOrFn</span><span class="token punctuation">(</span>parentVal<span class="token punctuation">,</span> childVal<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这段代码的作用是在 <code>strats</code> 策略对象上添加 <code>data</code> 策略函数，用来合并处理 <code>data</code> 选项。我们看看这个策略函数的内容，首先是一个判断分支：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>与 <code>el</code> 和 <code>propsData</code> 这两个策略函数相同，先判断是否传递了 <code>vm</code> 这个参数，我们知道当没有 <code>vm</code> 参数时，说明处理的是子组件的选项，那我们就看看对于子组件的选项它是如何处理的，<code>if</code> 判断语句块内的代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>childVal <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> childVal <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span>
    <span class="token string">'The &quot;data&quot; option should be a function '</span> <span class="token operator">+</span>
    <span class="token string">'that returns a per-instance value in component '</span> <span class="token operator">+</span>
    <span class="token string">'definitions.'</span><span class="token punctuation">,</span>
    vm
  <span class="token punctuation">)</span>

  <span class="token keyword">return</span> parentVal
<span class="token punctuation">}</span>
<span class="token keyword">return</span> <span class="token function">mergeDataOrFn</span><span class="token punctuation">(</span>parentVal<span class="token punctuation">,</span> childVal<span class="token punctuation">)</span>
</code></pre></div><p>首先判断是否传递了子组件的 <code>data</code> 选项(即：<code>childVal</code>)，并且检测 <code>childVal</code> 的类型是不是 <code>function</code>，如果 <code>childVal</code> 的类型不是 <code>function</code> 则会给你一个警告，也就是说 <code>childVal</code> 应该是一个函数，如果不是函数会提示你 <code>data</code> 的类型必须是一个函数，这就是我们知道的：<em>子组件中的 <code>data</code> 必须是一个返回对象的函数</em>。如果不是函数，除了给你一段警告之外，会直接返回 <code>parentVal</code>。</p> <p>如果 <code>childVal</code> 是函数类型，那说明满足了子组件的 <code>data</code> 选项需要是一个函数的要求，那么就直接返回 <code>mergeDataOrFn</code> 函数的执行结果：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">return</span> <span class="token function">mergeDataOrFn</span><span class="token punctuation">(</span>parentVal<span class="token punctuation">,</span> childVal<span class="token punctuation">)</span>
</code></pre></div><p>上面的情况是在 <code>strats.data</code> 策略函数拿不到 <code>vm</code> 参数时的情况，如果拿到了 <code>vm</code> 参数，那么说明处理的选项不是子组件的选项，而是正常使用 <code>new</code> 操作符创建实例时的选项，这个时候则直接返回 <code>mergeDataOrFn</code> 的函数执行结果，但是会多透传一个参数 <code>vm</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">return</span> <span class="token function">mergeDataOrFn</span><span class="token punctuation">(</span>parentVal<span class="token punctuation">,</span> childVal<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
</code></pre></div><p>通过上面的分析我们得知一件事，即 <code>strats.data</code> 策略函数无论合并处理的是子组件的选项还是非子组件的选项，其最终都是调用 <code>mergeDataOrFn</code> 函数进行处理的，并且以 <code>mergeDataOrFn</code> 函数的返回值作为策略函数的最终返回值。有一点不同的是在处理非子组件选项的时候所调用的 <code>mergeDataOrFn</code> 函数多传递了一个参数 <code>vm</code>。所以接下来我们要做的事儿就是看看 <code>mergeDataOrFn</code> 的代码，看一看它的返回值是什么，因为它的返回值就等价于 <code>strats.data</code> 策略函数的返回值。<code>mergeDataOrFn</code> 函数的源码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Data
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mergeDataOrFn</span> <span class="token punctuation">(</span>
  parentVal<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  childVal<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  vm<span class="token operator">?</span><span class="token punctuation">:</span> Component
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token operator">?</span>Function <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// in a Vue.extend merge, both should be functions</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>childVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> parentVal
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>parentVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> childVal
    <span class="token punctuation">}</span>
    <span class="token comment">// when parentVal &amp; childVal are both present,</span>
    <span class="token comment">// we need to return a function that returns the</span>
    <span class="token comment">// merged result of both functions... no need to</span>
    <span class="token comment">// check if parentVal is a function here because</span>
    <span class="token comment">// it has to be a function to pass previous merges.</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">mergedDataFn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">mergeData</span><span class="token punctuation">(</span>
        <span class="token keyword">typeof</span> childVal <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> childVal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> childVal<span class="token punctuation">,</span>
        <span class="token keyword">typeof</span> parentVal <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> parentVal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> parentVal
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">mergedInstanceDataFn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// instance merge</span>
      <span class="token keyword">const</span> instanceData <span class="token operator">=</span> <span class="token keyword">typeof</span> childVal <span class="token operator">===</span> <span class="token string">'function'</span>
        <span class="token operator">?</span> childVal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
        <span class="token punctuation">:</span> childVal
      <span class="token keyword">const</span> defaultData <span class="token operator">=</span> <span class="token keyword">typeof</span> parentVal <span class="token operator">===</span> <span class="token string">'function'</span>
        <span class="token operator">?</span> parentVal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
        <span class="token punctuation">:</span> parentVal
      <span class="token keyword">if</span> <span class="token punctuation">(</span>instanceData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">mergeData</span><span class="token punctuation">(</span>instanceData<span class="token punctuation">,</span> defaultData<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> defaultData
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个函数整体由 <code>if</code> 判断分支语句块组成，首先对 <code>vm</code> 进行判断，我们知道无论是子组件选项还是非子组件选项 <code>strats.data</code> 策略函数都是通过调用 <code>mergeDataOrFn</code> 函数来完成处理的，且处理非子组件选项的时候要比处理子组件选项时多传递了一个参数 <code>vm</code>，这就使得 <code>mergeDataOrFn</code> 也能通过是否有 <code>vm</code> 来区分处理的是不是子组件选项。如果没有拿到 <code>vm</code> 参数的话，那说明处理的是子组件选项，程序会走 <code>if</code> 分支，实际上我们可以看到这里有段注释：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// in a Vue.extend merge, both should be functions</span>
</code></pre></div><p>这段注释的意思是：选项是在调用 <code>Vue.extend</code> 函数时进行合并处理的，此时父子 <code>data</code> 选项都应该是函数。</p> <p>这再次说明了，当拿不到 <code>vm</code> 这个参数的时候，合并操作是在 <code>Vue.extend</code> 中进行的，也就是在处理子组件的选项。而且此时 <code>childVal</code> 和 <code>parentVal</code> 都应该是函数，那么这里真的能保证 <code>childVal</code> 和 <code>parentVal</code> 都是函数了吗？其实是可以的，我们后面会讲到。</p> <p>在这句注释的下面是这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>childVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> parentVal
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>parentVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> childVal
<span class="token punctuation">}</span>
</code></pre></div><p>我们看第一个 <code>if</code> 语句块，如果没有 <code>childVal</code>，也就是说子组件的选项中没有 <code>data</code> 选项，那么直接返回 <code>parentVal</code>，比如下面的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>我们使用 <code>Vue.extend</code> 函数创建子类的时候传递的子组件选项是一个空对象，即没有 <code>data</code> 选项，那么此时 <code>parentVal</code> 实际上就是 <code>Vue.options</code>，由于 <code>Vue.options</code> 上也没有 <code>data</code> 这个属性，所以压根就不会执行 <code>strats.data</code> 策略函数，也就更不会执行 <code>mergeDataOrFn</code> 函数，有的同学可能会问：既然都没有执行，那么这里的 <code>return parentVal</code> 是不是多余的？当然不多余，因为 <code>parentVal</code> 存在有值的情况。那么什么时候才会出现 <code>childVal</code> 不存在但是 <code>parentVal</code> 存在的情况呢？看下面的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> Parent <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  data<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      test<span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> Child <span class="token operator">=</span> Parent<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>上面的代码中 <code>Parent</code> 类继承了 <code>Vue</code>，而 <code>Child</code> 又继承了 <code>Parent</code>，关键就在于我们使用 <code>Parent.extend</code> 创建 <code>Child</code> 子类的时候，对于 <code>Child</code> 类来讲，<code>childVal</code> 不存在，因为我们没有传递 <code>data</code> 选项，但是 <code>parentVal</code> 存在，即 <code>Parent.options</code> 下的 <code>data</code> 选项，那么 <code>Parent.options</code> 是哪里来的呢？实际就是 <code>Vue.extend</code> 函数内使用 <code>mergeOptions</code> 生成的，所以此时 <code>parentVal</code> 必定是个函数，因为 <code>strats.data</code> 策略函数在处理 <code>data</code> 选项后返回的始终是一个函数。</p> <p>所以现在再看这段代码就清晰多了：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>childVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> parentVal
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>parentVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> childVal
<span class="token punctuation">}</span>
</code></pre></div><p>由于 <code>childVal</code> 和 <code>parentVal</code> 必定会有其一，否则便不会执行 <code>strats.data</code> 策略函数，所以上面判断的意思就是：<em>如果没有子选项则使用父选项，没有父选项就直接使用子选项，且这两个选项都能保证是函数</em>，如果父子选项同时存在，则代码继续进行，将执行下面的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// when parentVal &amp; childVal are both present,</span>
<span class="token comment">// we need to return a function that returns the</span>
<span class="token comment">// merged result of both functions... no need to</span>
<span class="token comment">// check if parentVal is a function here because</span>
<span class="token comment">// it has to be a function to pass previous merges.</span>
<span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">mergedDataFn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">mergeData</span><span class="token punctuation">(</span>
    <span class="token keyword">typeof</span> childVal <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> childVal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> childVal<span class="token punctuation">,</span>
    <span class="token keyword">typeof</span> parentVal <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> parentVal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> parentVal
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>也就是说，当父子选项同时存在，那么就返回一个函数 <code>mergedDataFn</code>，注意：此时代码运行就结束了，因为函数已经返回了(<code>return</code>)，至于 <code>mergedDataFn</code> 函数里面又返回了 <code>mergeData</code> 函数的执行结果这句代码目前还没有执行。</p> <p>以上就是 <code>strats.data</code> 策略函数在处理子组件的 <code>data</code> 选项时所做的事，我们可以发现 <code>mergeDataOrFn</code> 函数在处理子组件选项时返回的总是一个函数，这也就间接导致 <code>strats.data</code> 策略函数在处理子组件选项时返回的也总是一个函数。</p> <p>说完了处理子组件选项的情况，我们再看看处理非子组件选项的情况，也就是使用 <code>new</code> 操作符创建实例时的情况，此时程序直接执行 <code>strats.data</code> 函数的最后一句代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">return</span> <span class="token function">mergeDataOrFn</span><span class="token punctuation">(</span>parentVal<span class="token punctuation">,</span> childVal<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
</code></pre></div><p>我们发现同样是调用 <code>mergeDataOrFn</code> 函数，只不过这个时候传递了 <code>vm</code> 参数，也就是说这将会执行 <code>mergeDataOrFn</code> 的 <code>else</code> 分支：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">mergedInstanceDataFn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// instance merge</span>
    <span class="token keyword">const</span> instanceData <span class="token operator">=</span> <span class="token keyword">typeof</span> childVal <span class="token operator">===</span> <span class="token string">'function'</span>
      <span class="token operator">?</span> childVal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
      <span class="token punctuation">:</span> childVal
    <span class="token keyword">const</span> defaultData <span class="token operator">=</span> <span class="token keyword">typeof</span> parentVal <span class="token operator">===</span> <span class="token string">'function'</span>
      <span class="token operator">?</span> parentVal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
      <span class="token punctuation">:</span> parentVal
    <span class="token keyword">if</span> <span class="token punctuation">(</span>instanceData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">mergeData</span><span class="token punctuation">(</span>instanceData<span class="token punctuation">,</span> defaultData<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> defaultData
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果走了 <code>else</code> 分支的话那么就直接返回 <code>mergedInstanceDataFn</code> 函数，注意此时的 <code>mergedInstanceDataFn</code> 函数同样还没有执行，它是 <code>mergeDataOrFn</code> 函数的返回值，所以这再次说明了一个问题：<em><code>mergeDataOrFn</code> 函数永远返回一个函数</em>。</p> <p>也就是说，假如以我们的例子为例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    test<span class="token punctuation">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>我们的 <code>data</code> 选项在经过 <code>mergeOptions</code> 处理之后将变成一个函数，且根据我们的分析，它应该就是 <code>mergedInstanceDataFn</code> 函数，我们可以在控制台打印如下信息：</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>$options<span class="token punctuation">)</span>
</code></pre></div><p>输出如下图：</p> <p><img src="http://ovjvjtt4l.bkt.clouddn.com/2017-10-20-102839.jpg" alt></p> <p>我们可以发现 <code>data</code> 选项确实被 <code>mergeOptions</code> 处理成了一个函数，且当 <code>data</code> 选项为非子组件的选项时，该函数就是 <code>mergedInstanceDataFn</code>。</p> <p>一个简单的总结，现在我们了解到了一个事实，即 <code>data</code> 选项最终被 <code>mergeOptions</code> 函数处理成了一个函数，当合并处理的是子组件的选项时 <code>data</code> 函数可能是以下三者之一：</p> <ul><li>1、就是 <code>data</code> 本身，因为子组件的 <code>data</code> 选项本身就是一个函数，即如下 <code>mergeDataOrFn</code> 函数的代码段所示：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mergeDataOrFn</span> <span class="token punctuation">(</span>
  parentVal<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  childVal<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  vm<span class="token operator">?</span><span class="token punctuation">:</span> Component
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token operator">?</span>Function <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token comment">// 返回子组件的 data 选项本身</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>parentVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> childVal
    <span class="token punctuation">}</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>2、父类的 <code>data</code> 选项，如下代码段所示：：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mergeDataOrFn</span> <span class="token punctuation">(</span>
  parentVal<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  childVal<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  vm<span class="token operator">?</span><span class="token punctuation">:</span> Component
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token operator">?</span>Function <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token comment">// 返回父类的 data 选项</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>childVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> parentVal
    <span class="token punctuation">}</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>3、<code>mergedDataFn</code> 函数，如下代码段所示：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mergeDataOrFn</span> <span class="token punctuation">(</span>
  parentVal<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  childVal<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  vm<span class="token operator">?</span><span class="token punctuation">:</span> Component
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token operator">?</span>Function <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token comment">// 返回 mergedDataFn 函数</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">mergedDataFn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">mergeData</span><span class="token punctuation">(</span>
        <span class="token keyword">typeof</span> childVal <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> childVal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> childVal<span class="token punctuation">,</span>
        <span class="token keyword">typeof</span> parentVal <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> parentVal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> parentVal
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当合并处理的是非子组件的选项时 <code>data</code> 函数为 <code>mergedInstanceDataFn</code> 函数，如下代码段所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">mergeDataOrFn</span> <span class="token punctuation">(</span>
  parentVal<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  childVal<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  vm<span class="token operator">?</span><span class="token punctuation">:</span> Component
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token operator">?</span>Function <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当合并处理的是非子组件的选项时 `data` 函数为 `mergedInstanceDataFn` 函数</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">mergedInstanceDataFn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// instance merge</span>
      <span class="token keyword">const</span> instanceData <span class="token operator">=</span> <span class="token keyword">typeof</span> childVal <span class="token operator">===</span> <span class="token string">'function'</span>
        <span class="token operator">?</span> childVal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
        <span class="token punctuation">:</span> childVal
      <span class="token keyword">const</span> defaultData <span class="token operator">=</span> <span class="token keyword">typeof</span> parentVal <span class="token operator">===</span> <span class="token string">'function'</span>
        <span class="token operator">?</span> parentVal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
        <span class="token punctuation">:</span> parentVal
      <span class="token keyword">if</span> <span class="token punctuation">(</span>instanceData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">mergeData</span><span class="token punctuation">(</span>instanceData<span class="token punctuation">,</span> defaultData<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> defaultData
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所以这就是我们一直强调的：<em><code>data</code> 选项最终被处理为一个函数</em>。但是根据我们之前的分析可知，函数分几种情况，但它们都有一个共同的特点，即：<em>这些函数的执行结果就是最终的数据</em>。</p> <p>我们可以发现 <code>mergedDataFn</code> 和 <code>mergedInstanceDataFn</code> 这两个函数有一个共同的特点，内部都调用了 <code>mergeData</code> 处理数据并返回，我们先看一下 <code>mergedDataFn</code> 函数，其源码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">mergedDataFn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">mergeData</span><span class="token punctuation">(</span>
    <span class="token keyword">typeof</span> childVal <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> childVal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> childVal<span class="token punctuation">,</span>
    <span class="token keyword">typeof</span> parentVal <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> parentVal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> parentVal
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个函数直接返回了 <code>mergeData</code> 函数的执行结果，再看看 <code>mergedInstanceDataFn</code> 函数，其源码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">mergedInstanceDataFn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// instance merge</span>
  <span class="token keyword">const</span> instanceData <span class="token operator">=</span> <span class="token keyword">typeof</span> childVal <span class="token operator">===</span> <span class="token string">'function'</span>
    <span class="token operator">?</span> childVal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
    <span class="token punctuation">:</span> childVal
  <span class="token keyword">const</span> defaultData <span class="token operator">=</span> <span class="token keyword">typeof</span> parentVal <span class="token operator">===</span> <span class="token string">'function'</span>
    <span class="token operator">?</span> parentVal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
    <span class="token punctuation">:</span> parentVal
  <span class="token keyword">if</span> <span class="token punctuation">(</span>instanceData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">mergeData</span><span class="token punctuation">(</span>instanceData<span class="token punctuation">,</span> defaultData<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> defaultData
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们注意到 <code>mergedDataFn</code> 和 <code>mergedInstanceDataFn</code> 这两个函数都有类似这样的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">typeof</span> childVal <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> childVal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> childVal
<span class="token keyword">typeof</span> parentVal <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> parentVal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> parentVal
</code></pre></div><p>我们知道 <code>childVal</code> 要么是子组件的选项，要么是使用 <code>new</code> 操作符创建实例时的选项，无论是哪一种，总之 <code>childVal</code> 要么是函数，要么就是一个纯对象。所以如果是函数的话就通过执行该函数从而获取到一个纯对象，所以类似上面那段代码中判断 <code>childVal</code> 和 <code>parentVal</code> 的类型是否是函数的目的只有一个，获取数据对象(纯对象)。所以 <code>mergedDataFn</code> 和 <code>mergedInstanceDataFn</code> 函数内部调用 <code>mergeData</code> 方法时传递的两个参数就是两个纯对象(当然你可以简单的理解为两个JSON对象)。</p> <p>所以说既然知道了 <code>mergeData</code> 函数接收的两个参数就是两个纯对象，那么再看 <code>mergeData</code> 函数的代码就轻松多了，它才是终极合并策略，其源码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Helper that recursively merges two data objects together.
 */</span>
<span class="token keyword">function</span> <span class="token function">mergeData</span> <span class="token punctuation">(</span>to<span class="token punctuation">:</span> Object<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">:</span> <span class="token operator">?</span>Object<span class="token punctuation">)</span><span class="token punctuation">:</span> Object <span class="token punctuation">{</span>
  <span class="token comment">// 没有 from 直接返回 to</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">from</span><span class="token punctuation">)</span> <span class="token keyword">return</span> to
  <span class="token keyword">let</span> key<span class="token punctuation">,</span> toVal<span class="token punctuation">,</span> fromVal
  <span class="token keyword">const</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">)</span>
  <span class="token comment">// 遍历 from 的 key</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keys<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    key <span class="token operator">=</span> keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    toVal <span class="token operator">=</span> to<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    fromVal <span class="token operator">=</span> <span class="token keyword">from</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token comment">// 如果 from 对象中的 key 不在 to 对象中，则使用 set 函数为 to 对象设置 key 及相应的值</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">set</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> key<span class="token punctuation">,</span> fromVal<span class="token punctuation">)</span>
    <span class="token comment">// 如果 from 对象中的 key 也在 to 对象中，且这两个属性的值都是纯对象则递归进行深度合并</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPlainObject</span><span class="token punctuation">(</span>toVal<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isPlainObject</span><span class="token punctuation">(</span>fromVal<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">mergeData</span><span class="token punctuation">(</span>toVal<span class="token punctuation">,</span> fromVal<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 其他情况什么都不做</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> to
<span class="token punctuation">}</span>
</code></pre></div><p><code>mergeData</code> 函数接收两个参数 <code>to</code> 和 <code>from</code>，根据 <code>mergeData</code> 函数被调用时参数的传递顺序我们知道，<code>to</code> 对应的是 <code>childVal</code> 产生的纯对象，<code>from</code> 对应 <code>parentVal</code> 产生的纯对象，我们看 <code>mergeData</code> 第一句代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">from</span><span class="token punctuation">)</span> <span class="token keyword">return</span> to
</code></pre></div><p>如果没有 <code>from</code> 则直接返回 <code>to</code>，也就是说如果没有 <code>parentVal</code> 产生的值，就直接使用 <code>childVal</code> 产生的值。</p> <p>如果有 <code>parentVal</code> 产生的值，则代码继续向下运行，我们看 <code>mergeData</code> 最后的返回值：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">return</span> to
</code></pre></div><p>其返回的仍是 <code>to</code> 对象，所以你应该能猜的到 <code>mergeData</code> 函数的作用，可以简单理解为：<em>将 <code>from</code> 对象的属性混合到 <code>to</code> 对象中，也可以说是将 <code>parentVal</code> 对象的属性混合到 <code>childVal</code> 中</em>，最后返回的是处理后的 <code>childVal</code> 对象。</p> <p><code>mergeData</code> 的具体做法就是像上面 <code>mergeData</code> 函数的代码段中所注释的那样，对 <code>from</code> 对象的 <code>key</code> 进行遍历：</p> <ul><li><p>如果 <code>from</code> 对象中的 <code>key</code> 不在 <code>to</code> 对象中，则使用 <code>set</code> 函数为 <code>to</code> 对象设置 <code>key</code> 及相应的值。</p></li> <li><p>如果 <code>from</code> 对象中的 <code>key</code> 在 <code>to</code> 对象中，且这两个属性的值都是纯对象则递归地调用 <code>mergeData</code> 函数进行深度合并。</p></li> <li><p>其他情况不做处理。</p></li></ul> <p>上面提到了一个 <code>set</code> 函数，根据 <code>options.js</code> 文件头部的引用关系可知：这个函数来自于 <code>core/observer/index.js</code> 文件，实际上这个 <code>set</code> 函数就是 <code>Vue</code> 暴露给我们的全局API <code>Vue.set</code>。在这里由于我们还没有讲到 <code>set</code> 函数的具体实现，所以你就可以简单理解为 <code>set</code> 函数的功能与我们前面遇到过的 <code>extend</code> 工具函数功能相似即可。</p> <p>所以我们知道了 <code>mergeData</code> 函数的执行结果才是真正的数据对象，由于 <code>mergedDataFn</code> 和 <code>mergedInstanceDataFn</code> 这两个函数的返回值就是 <code>mergeData</code> 函数的执行结果，所以 <code>mergedDataFn</code> 和 <code>mergedInstanceDataFn</code> 函数的执行将会得到数据对象，我们还知道 <code>data</code> 选项会被 <code>mergeOptions</code> 处理成函数，比如处理成 <code>mergedInstanceDataFn</code>，所以：<em>最终得到的 <code>data</code> 选项是一个函数，且该函数的执行结果就是最终的数据对象</em>。</p> <p>最后我们对大家经常会产生疑问的地方做一些补充：</p> <h3 id="一、为什么最终-strats-data-会被处理成一个函数？"><a href="#一、为什么最终-strats-data-会被处理成一个函数？" aria-hidden="true" class="header-anchor">#</a> 一、为什么最终 <code>strats.data</code> 会被处理成一个函数？</h3> <p>这是因为，通过函数返回数据对象，保证了每个组件实例都有一个唯一的数据副本，避免了组件间数据互相影响。后面讲到 <code>Vue</code> 的初始化的时候大家会看到，在初始化数据状态的时候，就是通过执行 <code>strats.data</code> 函数来获取数据并对其进行处理的。</p> <h3 id="二、为什么不在合并阶段就把数据合并好，而是要等到初始化的时候再合并数据？"><a href="#二、为什么不在合并阶段就把数据合并好，而是要等到初始化的时候再合并数据？" aria-hidden="true" class="header-anchor">#</a> 二、为什么不在合并阶段就把数据合并好，而是要等到初始化的时候再合并数据？</h3> <p>这个问题是什么意思呢？我们知道在合并阶段 <code>strats.data</code> 将被处理成一个函数，但是这个函数并没有被执行，而是到了后面初始化的阶段才执行的，这个时候才会调用 <code>mergeData</code> 对数据进行合并处理，那这么做的目的是什么呢？</p> <p>其实这么做是有原因的，后面讲到 <code>Vue</code> 的初始化的时候，大家就会发现 <code>inject</code> 和 <code>props</code> 这两个选项的初始化是先于 <code>data</code> 选项的，这就保证了我们能够使用 <code>props</code> 初始化 <code>data</code> 中的数据，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 子组件：使用 props 初始化子组件的 childData </span>
<span class="token keyword">const</span> Child <span class="token operator">=</span> <span class="token punctuation">{</span>
  template<span class="token punctuation">:</span> <span class="token string">'&lt;span&gt;&lt;/span&gt;'</span><span class="token punctuation">,</span>
  <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      childData<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>parentData
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'parentData'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function">created</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里将输出 parent</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>childData<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    <span class="token comment">// 通过 props 向子组件传递数据</span>
    template<span class="token punctuation">:</span> <span class="token string">'&lt;child parent-data=&quot;parent&quot; /&gt;'</span><span class="token punctuation">,</span>
    components<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      Child
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>如上例所示，子组件的数据 <code>childData</code> 的初始值就是 <code>parentData</code> 这个 <code>props</code>。而之所以能够这样做的原因有两个</p> <ul><li>1、由于 <code>props</code> 的初始化先于 <code>data</code> 选项的初始化</li> <li>2、<code>data</code> 选项是在初始化的时候才求值的，你也可以理解为在初始化的时候才使用 <code>mergeData</code> 进行数据合并。</li></ul> <h3 id="三、你可以这么做。"><a href="#三、你可以这么做。" aria-hidden="true" class="header-anchor">#</a> 三、你可以这么做。</h3> <p>在上面的例子中，子组件的 <code>data</code> 选项我们是这么写的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    childData<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>parentData
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但你知道吗，你也可以这么写：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">data</span> <span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    childData<span class="token punctuation">:</span> vm<span class="token punctuation">.</span>parentData
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 或者使用更简单的解构赋值</span>
<span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> parentData <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    childData<span class="token punctuation">:</span> parentData
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们可以通过解构赋值的方式，也就是说 <code>data</code> 函数的参数就是当前实例对象。那么这个参数是在哪里传递进来的呢？其实有两个地方，其中一个地方我们前面见过了，如下面这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">mergedDataFn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">mergeData</span><span class="token punctuation">(</span>
    <span class="token keyword">typeof</span> childVal <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> childVal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> childVal<span class="token punctuation">,</span>
    <span class="token keyword">typeof</span> parentVal <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> parentVal<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> parentVal
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意这里的 <code>childVal.call(this, this)</code> 和 <code>parentVal.call(this, this)</code>，关键在于 <code>call(this, this)</code>，可以看到，第一个 <code>this</code> 指定了 <code>data</code> 函数的作用域，而第二个 <code>this</code> 就是传递给 <code>data</code> 函数的参数。</p> <p>当然了仅仅在这里这么做是不够的，比如 <code>mergedDataFn</code> 前面的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>childVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> parentVal
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>parentVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> childVal
<span class="token punctuation">}</span>
</code></pre></div><p>在这段代码中，直接将 <code>parentVal</code> 或 <code>childVal</code> 返回了，我们知道这里的 <code>parentVal</code> 和 <code>childVal</code> 就是 <code>data</code> 函数，由于被直接返回，所以并没有指定其运行的作用域，且也没有传递当前实例作为参数，所以我们必然还是在其他地方做这些事情，而这个地方就是我们说的第二个地方，它在哪里呢？当然是初始化的时候，后面我们会讲到的，如果这里大家没有理解也不用担心。</p> <h2 id="生命周期钩子选项的合并策略"><a href="#生命周期钩子选项的合并策略" aria-hidden="true" class="header-anchor">#</a> 生命周期钩子选项的合并策略</h2> <p>现在我们看完了 <code>strats.data</code> 策略函数，我们继续按照 <code>options.js</code> 文件的顺序看代码，接下来的一段代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Hooks and props are merged as arrays.
 */</span>
<span class="token keyword">function</span> <span class="token function">mergeHook</span> <span class="token punctuation">(</span>
  parentVal<span class="token punctuation">:</span> <span class="token operator">?</span>Array<span class="token operator">&lt;</span>Function<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  childVal<span class="token punctuation">:</span> <span class="token operator">?</span>Function <span class="token operator">|</span> <span class="token operator">?</span>Array<span class="token operator">&lt;</span>Function<span class="token operator">&gt;</span>
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token operator">?</span>Array<span class="token operator">&lt;</span>Function<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> childVal
    <span class="token operator">?</span> parentVal
      <span class="token operator">?</span> parentVal<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>childVal<span class="token punctuation">)</span>
      <span class="token punctuation">:</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>childVal<span class="token punctuation">)</span>
        <span class="token operator">?</span> childVal
        <span class="token punctuation">:</span> <span class="token punctuation">[</span>childVal<span class="token punctuation">]</span>
    <span class="token punctuation">:</span> parentVal
<span class="token punctuation">}</span>

<span class="token constant">LIFECYCLE_HOOKS</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>hook <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  strats<span class="token punctuation">[</span>hook<span class="token punctuation">]</span> <span class="token operator">=</span> mergeHook
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>看上去，这段代码貌似是用来合并生命周期钩子的，事实上的确是这样，我们看看它是怎么做的，首先上面的代码由两部分组成：<code>mergeHook</code> 函数和一个 <code>forEach</code> 语句。我们先看下面的 <code>forEach</code> 语句：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">LIFECYCLE_HOOKS</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>hook <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  strats<span class="token punctuation">[</span>hook<span class="token punctuation">]</span> <span class="token operator">=</span> mergeHook
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>使用 <code>forEach</code> 遍历 <code>LIFECYCLE_HOOKS</code> 常量，那说明这个常量应该是一个数组，我们根据 <code>options.js</code> 文件头部的引用关系可知 <code>LIFECYCLE_HOOKS</code> 常量来自于 <code>shared/constants.js</code> 文件，我们打开这个文件找到 <code>LIFECYCLE_HOOKS</code> 常量如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token constant">LIFECYCLE_HOOKS</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'beforeCreate'</span><span class="token punctuation">,</span>
  <span class="token string">'created'</span><span class="token punctuation">,</span>
  <span class="token string">'beforeMount'</span><span class="token punctuation">,</span>
  <span class="token string">'mounted'</span><span class="token punctuation">,</span>
  <span class="token string">'beforeUpdate'</span><span class="token punctuation">,</span>
  <span class="token string">'updated'</span><span class="token punctuation">,</span>
  <span class="token string">'beforeDestroy'</span><span class="token punctuation">,</span>
  <span class="token string">'destroyed'</span><span class="token punctuation">,</span>
  <span class="token string">'activated'</span><span class="token punctuation">,</span>
  <span class="token string">'deactivated'</span><span class="token punctuation">,</span>
  <span class="token string">'errorCaptured'</span>
<span class="token punctuation">]</span>
</code></pre></div><p>可以发现 <code>LIFECYCLE_HOOKS</code> 常量实际上是由与生命周期钩子同名的字符串组成的数组。</p> <p>所以现在再回头来看那段 <code>forEach</code> 语句可知，它的作用就是在 <code>strats</code> 策略对象上添加用来合并各个生命周期钩子选项的策略函数，并且这些生命周期钩子选项的策略函数相同：<em>都是 <code>mergeHook</code> 函数</em>。</p> <p>那么 <code>mergeHook</code> 函数是怎样合并生命周期选项的呢？我们看看 <code>mergeHook</code> 函数的代码，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mergeHook</span> <span class="token punctuation">(</span>
  parentVal<span class="token punctuation">:</span> <span class="token operator">?</span>Array<span class="token operator">&lt;</span>Function<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  childVal<span class="token punctuation">:</span> <span class="token operator">?</span>Function <span class="token operator">|</span> <span class="token operator">?</span>Array<span class="token operator">&lt;</span>Function<span class="token operator">&gt;</span>
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token operator">?</span>Array<span class="token operator">&lt;</span>Function<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> childVal
    <span class="token operator">?</span> parentVal
      <span class="token operator">?</span> parentVal<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>childVal<span class="token punctuation">)</span>
      <span class="token punctuation">:</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>childVal<span class="token punctuation">)</span>
        <span class="token operator">?</span> childVal
        <span class="token punctuation">:</span> <span class="token punctuation">[</span>childVal<span class="token punctuation">]</span>
    <span class="token punctuation">:</span> parentVal
<span class="token punctuation">}</span>
</code></pre></div><p>整个函数体由三组<em>三目运算符</em>组成，有一点值得大家学习的就是这里写三目运算符的方式，是不是感觉非常地清晰易读？那么这段代码的分析我们同样使用与上面代码相同的格式来写：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">return</span> <span class="token punctuation">(</span>是否有 childVal，即判断组件的选项中是否有对应名字的生命周期钩子函数<span class="token punctuation">)</span>
  <span class="token operator">?</span> 如果有 childVal 则判断是否有 parentVal
    <span class="token operator">?</span> 如果有 parentVal 则使用 concat 方法将二者合并为一个数组
    <span class="token punctuation">:</span> 如果没有 parentVal 则判断 childVal 是不是一个数组
      <span class="token operator">?</span> 如果 childVal 是一个数组则直接返回
      <span class="token punctuation">:</span> 否则将其作为数组的元素，然后返回数组
  <span class="token punctuation">:</span> 如果没有 childVal 则直接返回 parentVal
</code></pre></div><p>如上就是对 <code>mergeHook</code> 函数的解读，我们可以发现，在经过 <code>mergeHook</code> 函数处理之后，组件选项的生命周期钩子函数被合并成一个数组。第一个三目运算符需要注意，它判断是否有 <code>childVal</code>，即组件的选项是否写了生命周期钩子函数，如果没有则直接返回了 <code>parentVal</code>，这里有个问题：<code>parentVal</code> 一定是数组吗？答案是：<em>如果有 <code>parentVal</code> 那么其一定是数组，如果没有 <code>parentVal</code> 那么 <code>strats[hooks]</code> 函数根本不会执行</em>。我们以 <code>created</code> 生命周期钩子函数为例：</p> <p>如下代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  created<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'created'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>如果以这段代码为例，那么对于 <code>strats.created</code> 策略函数来讲(注意这里的 <code>strats.created</code> 就是 <code>mergeHooks</code>)，<code>childVal</code> 就是我们例子中的 <code>created</code> 选项，它是一个函数。<code>parentVal</code> 应该是 <code>Vue.options.created</code>，但 <code>Vue.options.created</code> 是不存在的，所以最终经过 <code>strats.created</code> 函数的处理将返回一个数组：</p> <div class="language-js extra-class"><pre class="language-js"><code>options<span class="token punctuation">.</span>created <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'created'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>  
<span class="token punctuation">]</span>
</code></pre></div><p>再看下面的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> Parent <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  created<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parentVal'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> Child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  created<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'childVal'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>其中 <code>Child</code> 是使用 <code>new Parent</code> 生成的，所以对于 <code>Child</code> 来讲，<code>childVal</code> 是：</p> <div class="language-js extra-class"><pre class="language-js"><code>created<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'childVal'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>而 <code>parentVal</code> 已经不是 <code>Vue.options.created</code> 了，而是 <code>Parent.options.created</code>，那么 <code>Parent.options.created</code> 是什么呢？它其实是通过 <code>Vue.extend</code> 函数内部的 <code>mergeOptions</code> 处理过的，所以它应该是这样的：</p> <div class="language-js extra-class"><pre class="language-js"><code>Parent<span class="token punctuation">.</span>options<span class="token punctuation">.</span>created <span class="token operator">=</span> <span class="token punctuation">[</span>
  created<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parentVal'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre></div><p>所以这个例子最终的结果就是既有 <code>childVal</code>，又有 <code>parentVal</code>，那么根据 <code>mergeHooks</code> 函数的逻辑：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mergeHook</span> <span class="token punctuation">(</span>
  parentVal<span class="token punctuation">:</span> <span class="token operator">?</span>Array<span class="token operator">&lt;</span>Function<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  childVal<span class="token punctuation">:</span> <span class="token operator">?</span>Function <span class="token operator">|</span> <span class="token operator">?</span>Array<span class="token operator">&lt;</span>Function<span class="token operator">&gt;</span>
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token operator">?</span>Array<span class="token operator">&lt;</span>Function<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> childVal
    <span class="token operator">?</span> parentVal
      <span class="token comment">// 这里，合并且生成一个新数组</span>
      <span class="token operator">?</span> parentVal<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>childVal<span class="token punctuation">)</span>
      <span class="token punctuation">:</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>childVal<span class="token punctuation">)</span>
        <span class="token operator">?</span> childVal
        <span class="token punctuation">:</span> <span class="token punctuation">[</span>childVal<span class="token punctuation">]</span>
    <span class="token punctuation">:</span> parentVal
<span class="token punctuation">}</span>
</code></pre></div><p>关键在这句：<code>parentVal.concat(childVal)</code>，将 <code>parentVal</code> 和 <code>childVal</code> 合并成一个数组。所以最终结果如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span>
  created<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parentVal'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  created<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'childVal'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre></div><p>另外我们注意第三个三目运算符：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">:</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>childVal<span class="token punctuation">)</span>
  <span class="token operator">?</span> childVal
  <span class="token punctuation">:</span> <span class="token punctuation">[</span>childVal<span class="token punctuation">]</span>
</code></pre></div><p>它判断了 <code>childVal</code> 是不是数组，这说明什么？说明了生命周期钩子是可以写成数组的，虽然 <code>Vue</code> 的文档里没有，不信你可以试试：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  created<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'first'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'second'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'third'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>钩子函数将按顺序执行。</p> <h2 id="资源-assets-选项的合并策略"><a href="#资源-assets-选项的合并策略" aria-hidden="true" class="header-anchor">#</a> 资源(assets)选项的合并策略</h2> <p>在 <code>Vue</code> 中 <code>directives</code>、<code>filters</code> 以及 <code>components</code> 被认为是资源，其实很好理解，指令、过滤器和组件都是可以作为第三方应用来提供的，比如你需要一个模拟滚动的组件，你当然可以选用超级强大的第三方组件 <a href="https://github.com/HcySunYang/scroll-flip-page" target="_blank" rel="noopener noreferrer">scroll-flip-page<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，所以这样看来 <a href="https://github.com/HcySunYang/scroll-flip-page" target="_blank" rel="noopener noreferrer">scroll-flip-page<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 就可以认为是资源，除了组件之外指令和过滤器也都是同样的道理。</p> <p>而我们接下来要看的代码就是用来合并处理 <code>directives</code>、<code>filters</code> 以及 <code>components</code> 等资源选项的，看如下代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */</span>
<span class="token keyword">function</span> <span class="token function">mergeAssets</span> <span class="token punctuation">(</span>
  parentVal<span class="token punctuation">:</span> <span class="token operator">?</span>Object<span class="token punctuation">,</span>
  childVal<span class="token punctuation">:</span> <span class="token operator">?</span>Object<span class="token punctuation">,</span>
  vm<span class="token operator">?</span><span class="token punctuation">:</span> Component<span class="token punctuation">,</span>
  key<span class="token punctuation">:</span> string
<span class="token punctuation">)</span><span class="token punctuation">:</span> Object <span class="token punctuation">{</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>parentVal <span class="token operator">||</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>childVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">assertObjectType</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> childVal<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">extend</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> childVal<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> res
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token constant">ASSET_TYPES</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  strats<span class="token punctuation">[</span>type <span class="token operator">+</span> <span class="token string">'s'</span><span class="token punctuation">]</span> <span class="token operator">=</span> mergeAssets
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>与生命周期钩子的合并处理策略基本一致，以上代码段也分为两部分：<code>mergeAssets</code> 函数以及一个 <code>forEach</code> 语句。我们同样先看 <code>forEach</code> 语句，这个 <code>forEach</code> 循环用来遍历 <code>ASSET_TYPES</code> 常量，根据 <code>options.js</code> 文件头部的引用关系可知 <code>ASSET_TYPES</code> 常量来自于 <code>shared/constants.js</code> 文件，我们打开 <code>shared/constants.js</code> 文件找到 <code>ASSET_TYPES</code> 常量如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token constant">ASSET_TYPES</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'component'</span><span class="token punctuation">,</span>
  <span class="token string">'directive'</span><span class="token punctuation">,</span>
  <span class="token string">'filter'</span>
<span class="token punctuation">]</span>
</code></pre></div><p>我们发现 <code>ASSET_TYPES</code> 其实是由与资源选项“同名”的三个字符串组成的数组，注意所谓的“同名”是带引号的，因为数组中的字符串与真正的资源选项名字相比要少一个字符 <code>s</code>。</p> <table><thead><tr><th>ASSET_TYPES</th> <th style="text-align:center">资源选项名字</th></tr></thead> <tbody><tr><td>component</td> <td style="text-align:center">component<code>s</code></td></tr> <tr><td>directive</td> <td style="text-align:center">directive<code>s</code></td></tr> <tr><td>filter</td> <td style="text-align:center">filter<code>s</code></td></tr></tbody></table> <p>所以我们再看一下那段 <code>forEach</code> 语句：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">ASSET_TYPES</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  strats<span class="token punctuation">[</span>type <span class="token operator">+</span> <span class="token string">'s'</span><span class="token punctuation">]</span> <span class="token operator">=</span> mergeAssets
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>我们发现在循环内部它有手动拼接上一个 <code>'s'</code>，所以最终的结果就是在 <code>strats</code> 策略对象上添加与资源选项名字相同的策略函数，用来分别合并处理三类资源。所以接下来我们就看看它是怎么处理的，<code>mergeAssets</code> 代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mergeAssets</span> <span class="token punctuation">(</span>
  parentVal<span class="token punctuation">:</span> <span class="token operator">?</span>Object<span class="token punctuation">,</span>
  childVal<span class="token punctuation">:</span> <span class="token operator">?</span>Object<span class="token punctuation">,</span>
  vm<span class="token operator">?</span><span class="token punctuation">:</span> Component<span class="token punctuation">,</span>
  key<span class="token punctuation">:</span> string
<span class="token punctuation">)</span><span class="token punctuation">:</span> Object <span class="token punctuation">{</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>parentVal <span class="token operator">||</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>childVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">assertObjectType</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> childVal<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">extend</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> childVal<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> res
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面的代码本身逻辑很简单，首先以 <code>parentVal</code> 为原型创建对象 <code>res</code>，然后判断是否有 <code>childVal</code>，如果有的话使用 <code>extend</code> 函数将 <code>childVal</code> 上的属性混合到 <code>res</code> 对象上并返回。如果没有 <code>childVal</code> 则直接返回 <code>res</code>。</p> <p>举个例子，大家知道任何组件的模板中我们都可以直接使用 <code>&lt;transition/&gt;</code> 组件或者 <code>&lt;keep-alive/&gt;</code> 等，但是我们并没有在我们自己的组件实例的 <code>components</code> 选项中显式地声明这些组件。那么这是怎么做到的呢？其实答案就在 <code>mergeAssets</code> 函数中。以下面的代码为例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  components<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    ChildComponent<span class="token punctuation">:</span> ChildComponent
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>上面的代码中，我们创建了一个 <code>Vue</code> 实例，并注册了一个子组件 <code>ChildComponent</code>，此时 <code>mergeAssets</code> 方法内的 <code>childVal</code> 就是例子中的 <code>components</code> 选项：</p> <div class="language-js extra-class"><pre class="language-js"><code>components<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  ChildComponent<span class="token punctuation">:</span> ChildComponent
<span class="token punctuation">}</span>
</code></pre></div><p>而 <code>parentVal</code> 就是 <code>Vue.options.components</code>，我们知道 <code>Vue.options</code> 如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span>options <span class="token operator">=</span> <span class="token punctuation">{</span>
	components<span class="token punctuation">:</span> <span class="token punctuation">{</span>
	  KeepAlive<span class="token punctuation">,</span>
	  Transition<span class="token punctuation">,</span>
	  TransitionGroup
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
	directives<span class="token punctuation">:</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	directives<span class="token punctuation">:</span><span class="token punctuation">{</span>
	  model<span class="token punctuation">,</span>
	  show
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
	filters<span class="token punctuation">:</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	_base<span class="token punctuation">:</span> Vue
<span class="token punctuation">}</span>
</code></pre></div><p>所以 <code>Vue.options.components</code> 就应该是一个对象：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  KeepAlive<span class="token punctuation">,</span>
  Transition<span class="token punctuation">,</span>
  TransitionGroup
<span class="token punctuation">}</span>
</code></pre></div><p>也就是说 <code>parentVal</code> 就是如上包含三个内置组件的对象，所以经过如下这句话之后：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> res <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>parentVal <span class="token operator">||</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
</code></pre></div><p>你可以通过 <code>res.KeepAlive</code> 访问到 <code>KeepAlive</code> 对象，因为虽然 <code>res</code> 对象自身属性没有 <code>KeepAlive</code>，但是它的原型上有。</p> <p>然后再经过 <code>return extend(res, childVal)</code> 这句话之后，<code>res</code> 变量将被添加 <code>ChildComponent</code> 属性，最终 <code>res</code> 如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>res <span class="token operator">=</span> <span class="token punctuation">{</span>
  ChildComponent
  <span class="token comment">// 原型</span>
  __proto__<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    KeepAlive<span class="token punctuation">,</span>
    Transition<span class="token punctuation">,</span>
    TransitionGroup
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所以这就是为什么我们不用显式地注册组件就能够使用一些内置组件的原因，同时这也是内置组件的实现方式，通过 <code>Vue.extend</code> 创建出来的子类也是一样的道理，一层一层地通过原型进行组件的搜索。</p> <p>最后说一下 <code>mergeAssets</code> 函数中的这句话：</p> <div class="language-js extra-class"><pre class="language-js"><code>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">assertObjectType</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> childVal<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
</code></pre></div><p>在非生产环境下，会调用 <code>assertObjectType</code> 函数，这个函数其实是用来检测 <code>childVal</code> 是不是一个纯对象的，如果不是纯对象会给你一个警告，其源码很简单，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">assertObjectType</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> string<span class="token punctuation">,</span> value<span class="token punctuation">:</span> any<span class="token punctuation">,</span> vm<span class="token punctuation">:</span> <span class="token operator">?</span>Component<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isPlainObject</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token template-string"><span class="token string">`Invalid value for option &quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&quot;: expected an Object, `</span></span> <span class="token operator">+</span>
      <span class="token template-string"><span class="token string">`but got </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">toRawType</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.`</span></span><span class="token punctuation">,</span>
      vm
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>就是使用 <code>isPlainObject</code> 进行判断。上面我们都在以 <code>components</code> 进行讲解，对于指令(<code>directives</code>)和过滤器(<code>filters</code>)也是一样的，因为他们都是用 <code>mergeAssets</code> 进行合并处理。</p> <h2 id="选项-watch-的合并策略"><a href="#选项-watch-的合并策略" aria-hidden="true" class="header-anchor">#</a> 选项 watch 的合并策略</h2> <p>接下来我们要看的代码就是这一段了：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */</span>
strats<span class="token punctuation">.</span><span class="token function-variable function">watch</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>
  parentVal<span class="token punctuation">:</span> <span class="token operator">?</span>Object<span class="token punctuation">,</span>
  childVal<span class="token punctuation">:</span> <span class="token operator">?</span>Object<span class="token punctuation">,</span>
  vm<span class="token operator">?</span><span class="token punctuation">:</span> Component<span class="token punctuation">,</span>
  key<span class="token punctuation">:</span> string
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token operator">?</span>Object <span class="token punctuation">{</span>
  <span class="token comment">// work around Firefox's Object.prototype.watch...</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>parentVal <span class="token operator">===</span> nativeWatch<span class="token punctuation">)</span> parentVal <span class="token operator">=</span> undefined
  <span class="token keyword">if</span> <span class="token punctuation">(</span>childVal <span class="token operator">===</span> nativeWatch<span class="token punctuation">)</span> childVal <span class="token operator">=</span> undefined
  <span class="token comment">/* istanbul ignore if */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>childVal<span class="token punctuation">)</span> <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>parentVal <span class="token operator">||</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">assertObjectType</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> childVal<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>parentVal<span class="token punctuation">)</span> <span class="token keyword">return</span> childVal
  <span class="token keyword">const</span> ret <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">extend</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> parentVal<span class="token punctuation">)</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> childVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> parent <span class="token operator">=</span> ret<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token keyword">const</span> child <span class="token operator">=</span> childVal<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parent <span class="token operator">=</span> <span class="token punctuation">[</span>parent<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
    ret<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> parent
      <span class="token operator">?</span> parent<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
      <span class="token punctuation">:</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token operator">?</span> child <span class="token punctuation">:</span> <span class="token punctuation">[</span>child<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> ret
<span class="token punctuation">}</span>
</code></pre></div><p>这一段代码的作用是在 <code>strats</code> 策略对象上添加 <code>watch</code> 策略函数。所以 <code>strats.watch</code> 策略函数应该是合并处理 <code>watch</code> 选项的。我们先看函数体开头的两句代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// work around Firefox's Object.prototype.watch...</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>parentVal <span class="token operator">===</span> nativeWatch<span class="token punctuation">)</span> parentVal <span class="token operator">=</span> undefined
<span class="token keyword">if</span> <span class="token punctuation">(</span>childVal <span class="token operator">===</span> nativeWatch<span class="token punctuation">)</span> childVal <span class="token operator">=</span> undefined
</code></pre></div><p>其中 <code>nativeWatch</code> 来自于 <code>core/util/env.js</code> 文件，大家可以在 <a href="/Blog/knowledge/appendix/core-util.html">core/util 目录下的工具方法全解</a> 中查看其作用。在 <code>Firefox</code> 浏览器中 <code>Object.prototype</code> 拥有原生的 <code>watch</code> 函数，所以即便一个普通的对象你没有定义 <code>watch</code> 属性，但是依然可以通过原型链访问到原生的 <code>watch</code> 属性，这就会给 <code>Vue</code> 在处理选项的时候造成迷惑，因为 <code>Vue</code> 也提供了一个叫做 <code>watch</code> 的选项，即使你的组件选项中没有写 <code>watch</code> 选项，但是 <code>Vue</code> 通过原型访问到了原生的 <code>watch</code>。这不是我们想要的，所以上面两句代码的目的是一个变通方案，当发现组件选项是浏览器原生的 <code>watch</code> 时，那说明用户并没有提供 <code>Vue</code> 的 <code>watch</code> 选项，直接重置为 <code>undefined</code>。</p> <p>然后是这句代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>childVal<span class="token punctuation">)</span> <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>parentVal <span class="token operator">||</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
</code></pre></div><p>检测了是否有 <code>childVal</code>，即组件选项是否有 <code>watch</code> 选项，如果没有的话，直接以 <code>parentVal</code> 为原型创建对象并返回(如果有 <code>parentVal</code> 的话)。</p> <p>如果组件选项中有 <code>watch</code> 选项，即 <code>childVal</code> 存在，则代码继续执行，接下来将执行这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">assertObjectType</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> childVal<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>parentVal<span class="token punctuation">)</span> <span class="token keyword">return</span> childVal
</code></pre></div><p>由于此时 <code>childVal</code> 存在，所以在非生产环境下使用 <code>assertObjectType</code> 函数对 <code>childVal</code> 进行类型检测，检测其是否是一个纯对象，我们知道 <code>Vue</code> 的 <code>watch</code> 选项需要是一个纯对象。接着判断是否有 <code>parentVal</code>，如果没有的话则直接返回 <code>childVal</code>，即直接使用组件选项的 <code>watch</code>。</p> <p>如果存在 <code>parentVal</code>，那么代码继续执行，此时 <code>parentVal</code> 以及 <code>childVal</code> 都将存在，那么就需要做合并处理了，也就是下面要执行的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 定义 ret 常量，其值为一个对象</span>
<span class="token keyword">const</span> ret <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 将 parentVal 的属性混合到 ret 中，后面处理的都将是 ret 对象，最后返回的也是 ret 对象</span>
<span class="token function">extend</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> parentVal<span class="token punctuation">)</span>
<span class="token comment">// 遍历 childVal</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> childVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 由于遍历的是 childVal，所以 key 是子选项的 key，父选项中未必能获取到值，所以 parent 未必有值</span>
  <span class="token keyword">let</span> parent <span class="token operator">=</span> ret<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
  <span class="token comment">// child 是肯定有值的，因为遍历的就是 childVal 本身</span>
  <span class="token keyword">const</span> child <span class="token operator">=</span> childVal<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
  <span class="token comment">// 这个 if 分支的作用就是如果 parent 存在，就将其转为数组</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    parent <span class="token operator">=</span> <span class="token punctuation">[</span>parent<span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
  ret<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> parent
    <span class="token comment">// 最后，如果 parent 存在，此时的 parent 应该已经被转为数组了，所以直接将 child concat 进去</span>
    <span class="token operator">?</span> parent<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
    <span class="token comment">// 如果 parent 不存在，直接将 child 转为数组返回</span>
    <span class="token punctuation">:</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token operator">?</span> child <span class="token punctuation">:</span> <span class="token punctuation">[</span>child<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token comment">// 最后返回新的 ret 对象</span>
<span class="token keyword">return</span> ret
</code></pre></div><p>上面的代码段中写了很详细的注释。首先定义了 <code>ret</code> 常量，最后返回的也是 <code>ret</code> 常量，所以中间的代码是在充实 <code>ret</code> 常量。之后使用 <code>extend</code> 函数将 <code>parentVal</code> 的属性混合到 <code>ret</code> 中。然后开始一个 <code>for in</code> 循环遍历 <code>childVal</code>，这个循环的目的是：<em>检测子选项中的值是否也在父选项中，如果在的话将父子选项合并到一个数组，否则直接把子选项变成一个数组返回</em>。</p> <p>举个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 创建子类</span>
<span class="token keyword">const</span> Sub <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// 检测 test 的变化</span>
  watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    test<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'extend: test change'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 使用子类创建实例</span>
<span class="token keyword">const</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    test<span class="token punctuation">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 检测 test 的变化</span>
  watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    test<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'instance: test change'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 修改 test 的值</span>
v<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token number">2</span>
</code></pre></div><p>上面的代码中，当我们修改 <code>v.test</code> 的值时，两个观察 <code>test</code> 变化的函数都将被执行。</p> <p>我们使用子类 <code>Sub</code> 创建了实例 <code>v</code>，对于实例 <code>v</code> 来讲，其 <code>childVal</code> 就是组件选项的 <code>watch</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code>watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  test<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'instance: test change'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>而其 <code>parentVal</code> 就是 <code>Sub.options</code>，实际上就是：</p> <div class="language-js extra-class"><pre class="language-js"><code>watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  test<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'extend: test change'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最终这两个 <code>watch</code> 选项将被合并为一个数组：</p> <div class="language-js extra-class"><pre class="language-js"><code>watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  test<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'extend: test change'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'instance: test change'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们可以通过打印实例的 <code>$options</code> 属性来确认这一点：</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>$options<span class="token punctuation">)</span>
</code></pre></div><p>如下图：</p> <p><img src="http://ovjvjtt4l.bkt.clouddn.com/2017-10-26-112916.jpg" alt></p> <p>可以发现 <code>watch.test</code> 变成了数组，但是 <code>watch.test</code> 并不一定总是数组，只有父选项(<code>parentVal</code>)也存在时它才是数组，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 创建实例</span>
<span class="token keyword">const</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    test<span class="token punctuation">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 检测 test 的变化</span>
  watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    test<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'instance: test change'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 修改 test 的值</span>
v<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token number">2</span>
</code></pre></div><p>我们直接使用 <code>Vue</code> 创建实例，这个时候对于实例 <code>v</code> 来说，父选项是 <code>Vue.options</code>，由于 <code>Vue.options</code> 并没有 <code>watch</code> 选项，所以逻辑将直接在 <code>strats.watch</code> 函数的这句话中返回：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>parentVal<span class="token punctuation">)</span> <span class="token keyword">return</span> childVal
</code></pre></div><p>没有 <code>parentVal</code> 即父选项中没有 <code>watch</code> 选项，则直接返回 <code>childVal</code>，也就是直接返回了子选项的 <code>watch</code> 选项，如就是例子中写的对象：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  test<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'instance: test change'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所以此时 <code>test</code> 字段就不再是数组了，而就是一个函数，同样可以通过打印实例的 <code>$options</code> 选项证明：</p> <p><img src="http://ovjvjtt4l.bkt.clouddn.com/2017-10-26-113858.jpg" alt></p> <p>所以大家应该知道：<em>被合并处理后的 <code>watch</code> 选项下的每个键值，有可能是一个数组，也有可能是一个函数</em>。</p> <h2 id="选项-props、methods、inject、computed-的合并策略"><a href="#选项-props、methods、inject、computed-的合并策略" aria-hidden="true" class="header-anchor">#</a> 选项 props、methods、inject、computed 的合并策略</h2> <p>接下来我们要看的一段代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Other object hashes.
 */</span>
strats<span class="token punctuation">.</span>props <span class="token operator">=</span>
strats<span class="token punctuation">.</span>methods <span class="token operator">=</span>
strats<span class="token punctuation">.</span>inject <span class="token operator">=</span>
strats<span class="token punctuation">.</span><span class="token function-variable function">computed</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>
  parentVal<span class="token punctuation">:</span> <span class="token operator">?</span>Object<span class="token punctuation">,</span>
  childVal<span class="token punctuation">:</span> <span class="token operator">?</span>Object<span class="token punctuation">,</span>
  vm<span class="token operator">?</span><span class="token punctuation">:</span> Component<span class="token punctuation">,</span>
  key<span class="token punctuation">:</span> string
<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token operator">?</span>Object <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>childVal <span class="token operator">&amp;&amp;</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">assertObjectType</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> childVal<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>parentVal<span class="token punctuation">)</span> <span class="token keyword">return</span> childVal
  <span class="token keyword">const</span> ret <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token function">extend</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> parentVal<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>childVal<span class="token punctuation">)</span> <span class="token function">extend</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> childVal<span class="token punctuation">)</span>
  <span class="token keyword">return</span> ret
<span class="token punctuation">}</span>
</code></pre></div><p>这段代码的作用是在 <code>strats</code> 策略对象上添加 <code>props</code>、<code>methods</code>、<code>inject</code> 以及 <code>computed</code> 策略函数，顾名思义这些策略函数是分别用来合并处理同名选项的，并且所使用的策略相同。</p> <p>对于 <code>props</code>、<code>methods</code>、<code>inject</code> 以及 <code>computed</code> 这四个选项有一个共同点，就是它们的结构都是纯对象，虽然我们在书写 <code>props</code> 或者 <code>inject</code> 选项的时候可能是一个数组，但是在 <a href="/Blog/knowledge/js/4vue-normalize.html">Vue的思路之选项的规范化</a> 一节中我们知道，<code>Vue</code> 内部都将其规范化为了一个对象。所以我们看看 <code>Vue</code> 是如何处理这些对象散列的。</p> <p>策略函数内容如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 如果存在 childVal，那么在非生产环境下要检查 childVal 的类型</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>childVal <span class="token operator">&amp;&amp;</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">assertObjectType</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> childVal<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// parentVal 不存在的情况下直接返回 childVal</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>parentVal<span class="token punctuation">)</span> <span class="token keyword">return</span> childVal
<span class="token comment">// 如果 parentVal 存在，则创建 ret 对象，然后分别将 parentVal 和 childVal 的属性混合到 ret 中，注意：由于 childVal 将覆盖 parentVal 的同名属性</span>
<span class="token keyword">const</span> ret <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token function">extend</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> parentVal<span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>childVal<span class="token punctuation">)</span> <span class="token function">extend</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> childVal<span class="token punctuation">)</span>
<span class="token comment">// 最后返回 ret 对象。</span>
<span class="token keyword">return</span> ret
</code></pre></div><p>首先，会检测 <code>childVal</code> 是否存在，即子选项是否有相关的属性，如果有的话在非生产环境下需要使用 <code>assertObjectType</code> 检测其类型，保证其类型是纯对象。然后会判断 <code>parentVal</code> 是否存在，不存在的话直接返回子选项。</p> <p>如果 <code>parentVal</code> 存在，则使用 <code>extend</code> 方法将其属性混合到新对象 <code>ret</code> 中，如果 <code>childVal</code> 也存在的话，那么同样会再使用 <code>extend</code> 函数将其属性混合到 <code>ret</code> 中，所以如果父子选项中有相同的键，那么子选项会把父选项覆盖掉。</p> <p>以上就是 <code>props</code>、<code>methods</code>、<code>inject</code> 以及 <code>computed</code> 这四个属性的通用合并策略。</p> <h2 id="选项-provide-的合并策略"><a href="#选项-provide-的合并策略" aria-hidden="true" class="header-anchor">#</a> 选项 provide 的合并策略</h2> <p>最后一个选项的合并策略，就是 <code>provide</code> 选项的合并策略，只有一句代码，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>strats<span class="token punctuation">.</span>provide <span class="token operator">=</span> mergeDataOrFn
</code></pre></div><p>也就是说 <code>provide</code> 选项的合并策略与 <code>data</code> 选项的合并策略相同，都是使用 <code>mergeDataOrFn</code> 函数。</p> <h2 id="选项处理小结"><a href="#选项处理小结" aria-hidden="true" class="header-anchor">#</a> 选项处理小结</h2> <p>现在我们了解了 <code>Vue</code> 中是如何合并处理选项的，接下来我们稍微做一个总结：</p> <ul><li>对于 <code>el</code>、<code>propsData</code> 选项使用默认的合并策略 <code>defaultStrat</code>。</li> <li>对于 <code>data</code> 选项，使用 <code>mergeDataOrFn</code> 函数进行处理，最终结果是 <code>data</code> 选项将变成一个函数，且该函数的执行结果为真正的数据对象。</li> <li>对于 <code>生命周期钩子</code> 选项，将合并成数组，使得父子选项中的钩子函数都能够被执行</li> <li>对于 <code>directives</code>、<code>filters</code> 以及 <code>components</code> 等资源选项，父子选项将以原型链的形式被处理，正是因为这样我们才能够在任何地方都使用内置组件、指令等。</li> <li>对于 <code>watch</code> 选项的合并处理，类似于生命周期钩子，如果父子选项都有相同的观测字段，将被合并为数组，这样观察者都将被执行。</li> <li>对于 <code>props</code>、<code>methods</code>、<code>inject</code>、<code>computed</code> 选项，父选项始终可用，但是子选项会覆盖同名的父选项字段。</li> <li>对于 <code>provide</code> 选项，其合并策略使用与 <code>data</code> 选项相同的 <code>mergeDataOrFn</code> 函数。</li> <li>最后，以上没有提及到的选项都将使默认选项 <code>defaultStrat</code>。</li> <li>最最后，默认合并策略函数 <code>defaultStrat</code> 的策略是：<em>只要子选项不是 <code>undefined</code> 就使用子选项，否则使用父选项</em>。</li></ul> <p>至此，我们大概介绍完了 <code>Vue</code> 对选项的处理，但留心的同学一定注意到了，<code>options.js</code> 文件的代码我们都基本逐行分析，唯独剩下一个函数我们始终没有提到，它就是 <code>resolveAsset</code> 函数。这个函数我们暂且不在这里讲，后面随着我们的深入，自然会再次碰到它，到那个时候应该是讲它的最好时机。</p> <h2 id="再看-mixins-和-extends"><a href="#再看-mixins-和-extends" aria-hidden="true" class="header-anchor">#</a> 再看 mixins 和 extends</h2> <p>在 <a href="/Blog/knowledge/js/4vue-normalize.html">Vue选项的规范化</a> 一节中，我们讲到了 <code>mergeOptions</code> 函数中的如下这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> extendsFrom <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token keyword">extends</span>
<span class="token class-name">if</span> <span class="token punctuation">(</span>extendsFrom<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  parent <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> extendsFrom<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>mixins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> child<span class="token punctuation">.</span>mixins<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    parent <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> child<span class="token punctuation">.</span>mixins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当时候我们并没有深入讲解，因为当时我们还不了解 <code>mergeOptions</code> 函数的作用，但是现在我们可以回头来看一下这段代码了。</p> <p>我们知道 <code>mixins</code> 在 <code>Vue</code> 中用于解决代码复用的问题，比如混入 <code>created</code> 生命周期钩子，用于打印一句话：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> consoleMixin <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">created</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'created:mixins'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">new</span> <span class="token class-name">Vue</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  mixins<span class="token punctuation">:</span> <span class="token punctuation">[</span>consoleMixin<span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function">created</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'created:instance'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>运行以上代码，将打印两句话：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// created:mixins</span>
<span class="token comment">// created:instance</span>
</code></pre></div><p>这是因为 <code>mergeOptions</code> 函数在处理 <code>mixins</code> 选项的时候递归调用了 <code>mergeOptions</code> 函数将 <code>mixins</code> 合并到了 <code>parent</code> 中，并将合并后生成的新对象作为新的 <code>parent</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>mixins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> child<span class="token punctuation">.</span>mixins<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    parent <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> child<span class="token punctuation">.</span>mixins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上例中我们只涉及到 <code>created</code> 生命周期钩子的合并，所以会使用生命周期钩子的合并策略函数进行处理，现在我们已经知道 <code>mergeOptions</code> 会把生命周期选项合并为一个数组，所以所有的生命周期钩子都会被执行。那么不仅仅是生命周期钩子，任何写在 <code>mixins</code> 中的选项，都会使用 <code>mergeOptions</code> 中相应的合并策略进行处理，这就是 <code>mixins</code> 的实现方式。</p> <p>对于 <code>extends</code> 选项，与 <code>mixins</code> 相同，甚至由于 <code>extends</code> 选项只能是一个对象，而不能是数组，反而要比 <code>mixins</code> 的实现更为简单，连遍历都不需要。</p></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/Blog/knowledge/js/4vue-normalize.html" class="prev">
          Vue 选项的规范化
        </a></span> <span class="next"><a href="/Blog/knowledge/js/6vue-init-start.html">
          Vue 的初始化之开篇
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/Blog/assets/js/app.cdba929c.js" defer></script><script src="/Blog/assets/js/11.68cb89c6.js" defer></script>
  </body>
</html>
